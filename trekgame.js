// TrekGame.js
// Generated on Sun Jul 21 16:44:05 EDT 2019
// Making Games By Year, Episode 1
// Script generated megafile from individual .js files
// Do not edit this file, edit individual scripts in the source dir and re-run compile.sh


// ------- globals.js ------- 
const mapWidthQuadrants = 8;
const mapHeightQuadrants = 6;
const quadrantWidthSectors = 10;
const quadrantHeightSectors = 10;
const sectorDisplayWidthChars = 4;
const minKlingonsGame = 8;


// ------- util.js ------- 
function checkArgumentsDefinedAndHaveValue(args)
{
    var x;
    for (x in args)
    {
        arg = args[x];
        console.assert(!(typeof arg == "undefined" || arg == null));
    }
}

function padStringToLength(str, len, padWithChar = ' ')
{
    console.assert(str.length <= len);
    console.assert(padWithChar.length == 1);

    checkArgumentsDefinedAndHaveValue(arguments);

    let padLength = len - str.length;
    let pad1 = Math.floor(padLength / 2);
    let pad2 = padLength - pad1;
    let padLeft = Math.max(pad1,pad2);

    let leftPadStr = str.padStart(padLeft + str.length, padWithChar);

    return leftPadStr.padEnd(len, padWithChar);
}

function randomInt(min, max)
{
    checkArgumentsDefinedAndHaveValue(arguments);
    return Math.round(Math.random() * (max-min) + min);
}

function randomFloat(min, max)
{
    checkArgumentsDefinedAndHaveValue(arguments);
    return (Math.random() * (max-min) + min);
}

function gameOutputScrollToBottom()
{
    let textarea = document.getElementById("gameOutputBox");
    textarea.scrollTop = textarea.scrollHeight;
}

function gameOutputAppend(str)
{
    let textarea = document.getElementById("gameOutputBox")
    textarea.value += str + '\n';
    textarea.scrollTop = textarea.scrollHeight;
}

function updateMap(mapString = game.currentQuadrant.toString())
{
    document.getElementById("map").innerHTML = mapString;
}

function updateMapHeader(str)
{
    document.getElementById("mapHeaderQuadrant").innerHTML = "<pre>"+str+"</pre>";
}

function updateMapFooter(str)
{
    document.getElementById("statusflags").innerHTML = "<pre>"+str+"</pre>";
}

function autosave(game)
{
    //console.log("autosave func");
    //console.log(JSON.stringify(game));

    if (game && !game.gameOver)
    {
        localStorage.setItem("autosave", JSON.stringify(game));

        let textarea = document.getElementById("gameOutputBox")
        localStorage.setItem("outputText", textarea.value);
    }
    else
    {
        localStorage.setItem("autosave", null);
        localStorage.setItem("outputText", null);
    }
}

function makeCDF(instanceProbabilities)
{
    var rval = [];
    let totalSum = 0.0;

    for (var x in instanceProbabilities)
    {
        totalSum += instanceProbabilities[x];
        rval.push(totalSum);
    }

    for (var x in rval)
    {
        rval[x] /= totalSum;
    }

    // last value should always be exactly 1
    rval[rval.length-1] = 1.0;

    return rval;
}

// generates a random value, between 0 and valueProbabilities.length-1, where each possible value's chance of
// being generated is listed in the corresponding array entry
function randomWithProbabilities(valueProbabilities)
{
    let randomVal = randomFloat(0.0, 1.0);
    let cdf = makeCDF(valueProbabilities);

    //console.log("" + cdf);
    var x;
    for (x in cdf)
    {
        if (randomVal < cdf[x])
        {
            return x;
        }
    }
    return cdf.length-1;
}

function mapFooter(length)
{
    let rval = "";

    for (var x = 0; x < length; x++)
    {
        rval += "=";
        rval += padStringToLength(""+(x+1), 3, '-');
    }

    return rval;
}

function mapHeader(length)
{
    let rval = "";

    for (var x = 0; x < length; x++)
    {
        rval += "=---";
    }

    return rval;
}

// ------- Grid.js ------- 
class Grid
{
    constructor(gridX, gridY, gridItemConstructor = function(){return null;})
    {
        checkArgumentsDefinedAndHaveValue(arguments);

        this.contents = new Array()

        this.width = gridX;
        this.height = gridY;
        this.size = gridX * gridY;

        for (let y = 0; y < this.height; y++)
        {
            for (let x = 0; x < this.width; x++)
            {
                this.contents.push(gridItemConstructor(x, y));
            }
        }
    }

    lookup(x,y)
    {
        checkArgumentsDefinedAndHaveValue(arguments);

        if (x < 0 || x >= this.width || y < 0 || y >= this.height)
        {
            return null;
        }

        return this.contents [y * this.width + x];
    }

    // 1D array based lookup
    lookup1D(x)
    {
        checkArgumentsDefinedAndHaveValue(arguments);
        return this.contents[x];
    }

    setValue(x,y,val)
    {
        checkArgumentsDefinedAndHaveValue(arguments);
        this.contents [y * this.width + x] = val;
    }

    setValue1D(x, val)
    {
        this.contents[x] = val;
    }

    getEmptySquare()
    {
        let startIndex = randomInt(0, this.contents.length-1);
        let emptyIndex = null;

        for (let i = 0; i < this.contents.length; i++)
        {
            let lookup = ( startIndex + i ) % this.contents.length;
            if (!this.contents.lookup)
            {
                emptyIndex = i;
                break;
            }
        }

        if (emptyIndex)
        {
            let rx = emptyIndex % this.width;
            let ry = emptyIndex / this.height;

            return {x : rx, y:ry};
        }
        
        return null;
    }

    toString()
    {
        let rval = "";
        for ( let y = 0; y < this.height; y++)
        {
            rval += padStringToLength(""+(y+1), 2) + '|';
            for (let x = 0; x < this.width; x++)
            {
                let catstr = this.lookup(x,y).toString();
                rval += catstr;
            }
            rval += '|';
            rval += '\n';
        }
        return rval;
    }
}

// ------- GameObject.js ------- 
class GameObject
{
    constructor(className)
    {
        this.sectorX = 0;
        this.sectorY = 0;
        this.quadrantX = 0;
        this.quadrantY = 0;
        this.entityType = this.constructor.name;

        if (className)
        {
            if (!className.Instances)
            {
                className.Instances = 0;
            }

            className.Instances++;
        }
    }

    isAdjacentTo(obj2)
    {
        let sameQuadrant = (this.quadrantX == obj2.quadrantX) && (this.quadrantY == obj2.quadrantY);
        let xSectorDiff = Math.abs(this.sectorX - obj2.sectorX);
        let ySectorDiff = Math.abs(this.sectorY - obj2.sectorY);

        console.log("quad x y " + sameQuadrant + " " + xSectorDiff + " " + ySectorDiff);

        return sameQuadrant && (xSectorDiff <= 1) && (ySectorDiff <= 1);
    }

    distanceToObject(obj2)
    {
        return this.distanceToSectorLoc(obj2.sectorX, obj2.sectorY);
    }

    distanceToSectorLoc(sectorX, sectorY)
    {
        let xdiff = this.sectorX - sectorX;
        let ydiff = this.sectorY - sectorY;
        return Math.sqrt(xdiff*xdiff + ydiff*ydiff);
    }

    setLocationSector(sectorXY)
    {
        this.sectorX = sectorXY.x;
        this.sectorY = sectorXY.y;
    }

    onTorpedoHit(game)
    {
        console.log("Torpedo hit (base class)");
    }

    // randomly generate the number of GameObject instances to put in a new quadrant
    static randomCountForQuadrant(quadrantFreeSpaces, instancesInQuadrant)
    {
        var rval = 0;

        let instanceProbabilities = this.quadrantInstanceProbabilities();
        if (instanceProbabilities == null)
        {
            //console.log("Using uniform probability path");
            rval = randomInt(0, this.maxInstancesQuadrant());
        }
        else
        {
            //console.log("Using CDF Probability Path");
            console.assert(instanceProbabilities.length == (1+this.maxInstancesQuadrant()));
            
            rval = randomWithProbabilities(instanceProbabilities);
        }

        rval = Math.min(rval, quadrantFreeSpaces);

        // createEntities occurs after we place our minimum number of entities around the map.
        // so if we've already created some entities in this quadrant just deduct them from the ones
        // the rng says we need to create.

        if (!this.Instances)
        {
            this.Instances = 0;
        }

        rval = Math.min(rval, this.maxInstancesGame() - this.Instances);

        console.assert(this.Instances <= this.maxInstancesGame());

        rval = Math.max(rval - instancesInQuadrant, 0);

        return rval;
    }

    sectorString()
    {
        return "" + (this.sectorX+1) + ", " + (this.sectorY+1);
    }

    quadrantString()
    {
        return "" + (this.quadrantX+1) + ", " + (this.quadrantY+1);
    }

    sectorStringFractional()
    {
        let sectorXFractional = (this.quadrantX+1) + (this.sectorX / quadrantWidthSectors);
        let sectorYFractional = (this.quadrantY+1) + (this.sectorY / quadrantHeightSectors);
        return "("+sectorXFractional+","+sectorYFractional+")";
    }

    static minInstancesGame()
    {
        return 0;
    }

    static maxInstancesQuadrant()
    {
        return 8;
    }

    static maxInstancesGame()
    {
        return this.maxInstancesQuadrant() * mapWidthQuadrants * mapHeightQuadrants;
    }

    // returns array containing the probability of each instance count appearing in a quadrant at map generation
    // eg. [.1, .2, .15, .55]
    // means that there's a 10% chance of no instances of the object in a given quadrant
    // there's a 20% chance of 1 instance
    // a 15% chance of 2 instances
    // a 55% chance of 3 instances
    // The base class GameObject method returns null, if we want to just generate uniform probabilities (default)
    // eg. each number between min and max has an equal likelihood.
    // So in the above example, there'd be a 25% chance of either no instance, 1 instance, 2 instances, or 3 instances
    static quadrantInstanceProbabilities()
    {
        return null;
    }
}

// ------- StarBase.js ------- 
class StarBase extends GameObject
{
    constructor()
    {
        super(StarBase);
        StarBase.starbaseList.push(this);
    }

    onTorpedoHit(game)
    {
        console.log("hit a starbase");
        gameOutputAppend("\nReport from sector " + this.sectorString());
        gameOutputAppend("The torpedo strikes and destroys the friendly starbase! I bet you'll be court martialled for that one!");

        game.currentQuadrant.removeEntity(this);
        StarBase.Instances--;

        let removeSB = this;
        StarBase.starbaseList = StarBase.starbaseList.filter(function(item){return item != removeSB});

        if (game.enterprise.dockStarbase == removeSB)
        {
            game.enterprise.undock(removeSB);
        }
    }

    toString()
    {
        return ">!<";
    }

    static maxInstancesQuadrant()
    {
        return 1;
    }

    static minInstancesGame()
    {
        return 1;
    }

    static quadrantInstanceProbabilities()
    {
        // 5% chance of a starbase in any given quadrant
        return [.95, .05];
    }
}

StarBase.starbaseList = [];

// ------- Planet.js ------- 
// planet lets you bombard with torpedoes when adjacent, in order to cause enemy ships to warp in
class Planet extends GameObject
{
    constructor()
    {
        super(Planet);
        this.bombarded = false;
    }

    onTorpedoHit(game)
    {
        gameOutputAppend("\nReport from sector " + this.sectorString());
        gameOutputAppend("The torpedo burns up in the planet's atmosphere.");
    }

    bombard()
    {
        this.bombarded = true;
    }

    toString()
    {
        return "O";
    }

    static maxInstancesGame()
    {
        return 1;
    }

    static maxInstancesQuadrant()
    {
        return 1;
    }

    static minInstancesGame()
    {
        return 0;
    }

    static quadrantInstanceProbabilities()
    {
        // 5% chance of a planet in any given quadrant
        return [.95, .05];
    }
}

// ------- Klingon.js ------- 
class Klingon extends GameObject
{
    constructor()
    {
        super(Klingon);
        this.shields = randomInt(100, 300);
    }

    onTorpedoHit(game)
    {
        console.log("hit a klingon");
        gameOutputAppend("\nReport from sector " + this.sectorString());
        
        game.destroyKlingon(this);
    }

    onPhaserHit(energy, game)
    {
        console.log("Klingon::onPhaserHit");
        let shieldDeflectionLevel = Klingon.shieldDeflectionPercent * this.shields;

        gameOutputAppend("\nReport from sector " + this.sectorString());

        if (energy <= shieldDeflectionLevel)
        {
            gameOutputAppend("Phaser hit did no damage!");
        }
        else
        {
            gameOutputAppend("Phaser hit the klingon fighter for " + energy + " damage.");

            this.shields -= energy;

            if (this.shields <= 0)
            {
                game.destroyKlingon(this);
            }
            else
            {
                if (game.currentQuadrantScanned)
                {
                    if (game.enterprise.canSeeEntity(this))
                    {
                       gameOutputAppend("" + this.shields + " units remain.");
                    }
                    else
                    {
                        gameOutputAppend("Sensor damage prevents reading the enemy's shields!");
                    }
                }
            }
        }
    }

    phaserDamageBase(dist)
    {
        let energyToFire = this.shields;
        return Math.round(energyToFire / dist);
    }

    firePhasers(target, game)
    {
        let dist = this.distanceToObject(target);
        let phaserDamage = this.phaserDamageBase(dist) * randomInt(Klingon.MinPhaserMultiplier, Klingon.MaxPhaserMultiplier);

        let sstr = game.enterprise.canSeeEntity(this) ? this.sectorString() : " ???? ";
        gameOutputAppend("\nHit from sector " + sstr + " for " + phaserDamage + " units");
        target.onPhaserHit(phaserDamage, game);
    }

    minPhaserDamage()
    {
        return Klingon.MinPhaserMultiplier * this.phaserDamageBase(1);
    }
    
    maxPhaserDamage()
    {
        return Klingon.MaxPhaserMultiplier * this.phaserDamageBase(1);
    }

    toString()
    {
        return "+K+";
    }
    
    static maxInstancesQuadrant()
    {
        return 4;
    }

    static quadrantInstanceProbabilities()
    {
        return [.9,  
                .025,
                .025,
                .0125,
                .00625
        ];
    }

    static maxInstancesGame()
    {
        return 18;
    }

    static minInstancesGame()
    {
        return minKlingonsGame;
    }
}

Klingon.shieldDeflectionPercent = .15;
Klingon.InstancesDestroyed = 0;
Klingon.MaxPhaserMultiplier = 3;
Klingon.MinPhaserMultiplier = 2;

// ------- Star.js ------- 
class Star extends GameObject
{
    constructor()
    {
        super(Star);
    }

    onTorpedoHit(game)
    {
        console.log("hit a star");
        gameOutputAppend("\nReport from sector " + this.sectorString(this.sectorX, this.sectorY));
        gameOutputAppend("The star absorbs the torpedo without a trace.");
    }

    toString()
    {
        return "*";
    }

    static maxInstancesQuadrant()
    {
        return 9;//12;
    }
}

// ------- ShipComponents.js ------- 
class ShipComponent
{
    constructor (componentName, damProb)
    {
        this.componentHealth = 1.0; //percent
        this.componentName = componentName;
        this.componentDamageProbability = damProb;
    }

    damageReport()
    {
    }

    passthroughDamage(enterprise, damage)
    {
        this.componentHealth -= Math.min(damage, this.componentHealth);
    }
}

// cap speed.
class WarpEnginesComponent extends ShipComponent
{
    constructor()
    {
        super("Warp Engines", .0625);
    }

    fullyFunctional()
    {
        return this.componentHealth >= WarpEnginesComponent.FullyFunctionalHealth;
    }

    damageReport()
    {
        gameOutputAppend("Warp can achieve " + this.maxSpeed() + " sectors per stardate");
    }

    maxSpeed()
    {
        let t = Math.min(1.0, this.componentHealth / WarpEnginesComponent.FullyFunctionalHealth);
        return (1.0 - t) * WarpEnginesComponent.MinSpeed + t * WarpEnginesComponent.MaxSpeed;
    }
}

WarpEnginesComponent.FullyFunctionalHealth = .8;

// min sectors to travel in a single stardate jump.  Cover at least sqrt(2) so we can go one sector in any direction even diagonal
WarpEnginesComponent.MinSpeed = 1.5;

// max sectors to travel in a single stardate jump.
WarpEnginesComponent.MaxSpeed = Math.sqrt(2.0) * Math.max(mapWidthQuadrants, mapHeightQuadrants);



class ShortRangeSensorsComponent extends ShipComponent
{
    constructor()
    {
        super("Short Range Sensors", .0625);
    }

    fullyFunctional()
    {
        return this.componentHealth > ShortRangeSensorsComponent.FullyFunctionalHealth;
    }

    chanceCorrupt()
    {
        // goes from 0 when the component is at the maximum health in range, to 1 when the component is at 0%
        let hnorm = (ShortRangeSensorsComponent.FullyFunctionalHealth - this.componentHealth) / ShortRangeSensorsComponent.FullyFunctionalHealth;

        // lerp
        let chanceCorrupt = (1.0 - hnorm) * ShortRangeSensorsComponent.MinChanceCorrupt + hnorm * ShortRangeSensorsComponent.MaxChanceCorrupt;

        return chanceCorrupt;
    }

    damageReport()
    {
        if (!this.fullyFunctional())
        {
            gameOutputAppend("Short range sensors are damaged.  Map display may be corrupted.");
        }
    }

    generateCorruptGrid()
    {
        this.corruptGrid = new Grid(quadrantWidthSectors, quadrantHeightSectors);

        let corruptChance = this.chanceCorrupt();

        for (var x in this.corruptGrid.contents)
        {
            this.corruptGrid.setValue1D(x, Math.random() < corruptChance);
        }
    }

    isSectorCorrupt1D(x)
    {
        return this.corruptGrid.lookup1D(x);
    }

    isSectorCorrupt(x, y)
    {
        return this.corruptGrid.lookup(x,y);
    }
}

ShortRangeSensorsComponent.FullyFunctionalHealth = .7;   // short range scan fully functional above this health
ShortRangeSensorsComponent.MinChanceCorrupt = .1;        // For a particular sector on the map, minimum chance it'll be corrupt when integrity is high
ShortRangeSensorsComponent.MaxChanceCorrupt = .75;       // For a particular sector on the map, maximum chance it'll be corrupt when integrity is low


class LongRangeSensorsComponent extends ShipComponent
{
    constructor()
    {
        super ("Long Range Sensors", .25);
    }

    functional()
    {
        return this.componentHealth >= LongRangeSensorsComponent.FullyFunctionalHealth;
    }

    damageReport()
    {
        if (!this.functional())
        {
            gameOutputAppend("Long range sensors disabled.");
        }
    }
}

LongRangeSensorsComponent.FullyFunctionalHealth = .8;


class PhaserControlComponent extends ShipComponent
{
    constructor()
    {
        super ("Phaser Control", .0625);
    }

    canFire()
    {
        return this.componentHealth >= PhaserControlComponent.DisabledThreshold;
    }

    phaserAccuracy()
    {
        let t = Math.min(this.componentHealth / PhaserControlComponent.FullyFunctionalHealth, 1.0);
        return (1.0 - t) * PhaserControlComponent.MinAccuracy + t; //lerp
    }

    isHit()
    {
        return Math.random() <= this.phaserAccuracy();
    }

    damageReport()
    {
        gameOutputAppend("Phasers Operable : " + (this.canFire() ? "YES" : "NO"));
        gameOutputAppend("Phaser Accuracy : " + (100*this.phaserAccuracy()) + "%");
    }
}

PhaserControlComponent.DisabledThreshold = .5;
PhaserControlComponent.FullyFunctionalHealth = .75;
PhaserControlComponent.MinAccuracy = .5;


class PhotonTubesComponent extends ShipComponent
{
    constructor()
    {
        super ("Photon Tubes", .125);
    }

    canFire()
    {
        return this.componentHealth > PhotonTubesComponent.DisabledThreshold;
    }

    targetingAvailable()
    {
        return this.componentHealth > PhotonTubesComponent.DamagedThreshold;
    }

    damageReport()
    {
        if (this.canFire())
        {
            if (!this.targetingAvailable())
            {
               gameOutputAppend("Due to damage, torpedo targeting computer is nonfunctional.  You will need to input torpedo trajectories manually until the system is repaired.");
            }

            gameOutputAppend("Expected accuracy : " + (100 * this.torpedoAccuracy()) + "%");
        }
        else
        {
            gameOutputAppend("Torpedo tubes too damaged to fire.");
        }
    }

    torpedoAccuracy()
    {
        let t = (this.componentHealth - PhotonTubesComponent.DisabledThreshold) / (PhotonTubesComponent.DamagedThreshold - PhotonTubesComponent.DisabledThreshold);
        t = Math.min(t, 1.0);
        return (1.0 - t) * PhotonTubesComponent.MinAccuracy + t;
    }

    isHit()
    {
        return Math.random() <= this.torpedoAccuracy();
    }
}

PhotonTubesComponent.MinAccuracy = .25;         // 25% chance to hit minimum for torpedoes
PhotonTubesComponent.DamagedThreshold = .5;     // 50% health = automatic targeting is down.
PhotonTubesComponent.DisabledThreshold = .25;   // 25% health = can't fire torpedoes.

// make the shield scan thing conditional.  in both places.
class ShieldControlComponent extends ShipComponent
{
    constructor()
    {
        super ("Shield Control", .125);
    }

    maxShields()
    {
        if (this.componentHealth >= ShieldControlComponent.FullyFunctionalHealth)
        {
            return ShieldControlComponent.MaxShields;
        }

        return (1.0 - this.componentHealth) * ShieldControlComponent.MaxShields + (this.componentHealth * ShieldControlComponent.MinShields);
    }

    passthroughDamage(enterprise, damage)
    {
        this.componentHealth -= Math.min(damage, this.componentHealth);

        if (enterprise.shields > this.maxShields())
        {
            enterprise.shields = this.maxShields();
            gameOutputAppend("Deflector shields hit!  Shield energy dropped to " + this.maxShields());
        }
    }

    damageReport()
    {
        gameOutputAppend("Deflector shield system can process " + this.maxShields() + " units of energy out of a possible " + ShieldControlComponent.MaxShields);
    }
}

ShieldControlComponent.MinShields = 0;
ShieldControlComponent.MaxShields = 2000; ///\todo calculate what kind of combat situations would minimally exceed this and prevent them in the generator
ShieldControlComponent.FullyFunctionalHealth = .8;

class LibraryComputerComponent extends ShipComponent
{
    constructor()
    {
        super ("Library Computer", .3125);
    }

    mapsAccessible()
    {
        return this.componentHealth > LibraryComputerComponent.MapsThreshold;
    }

    damageReportAvailable()
    {
        return this.componentHealth > LibraryComputerComponent.DamageReportThreshold;
    }

    damageReport()
    {
        if (!this.mapsAccessible())
        {
            gameOutputAppend("Ship computer is too damaged to access maps.");
        }
    }
}

LibraryComputerComponent.MapsThreshold = .25; // 25% health = can't access maps.
LibraryComputerComponent.DamageReportThreshold = .5; // 50% health = can't access damage report

// ------- Enterprise.js ------- 
class Enterprise extends GameObject
{
    canSeeEntity(entity)
    {
        return !this.components.ShortRangeSensors.isSectorCorrupt(entity.sectorX, entity.sectorY);
    }

    componentDamageProbabilities()
    {
        var probArray = [];

        for (var key in this.components)
        {
            console.log("" + this.components[key].componentDamageProbability);
            probArray.push(this.components[key].componentDamageProbability);
        }

        console.assert(probArray.length == Object.keys(this.components).length);
        return probArray;
    }

    constructor()
    {
        super(Enterprise);
        this.torpedoes = Enterprise.StartTorpedoes;
        this.shields = Enterprise.StartShields;

        this.freeEnergy = Enterprise.StartEnergy;

        this.components =   {
                                WarpEngines : new WarpEnginesComponent(), 
                                ShortRangeSensors: new ShortRangeSensorsComponent(),
                                LongRangeSensors: new LongRangeSensorsComponent(),
                                PhaserControl : new PhaserControlComponent(),
                                PhotonTubes : new PhotonTubesComponent(),
                                ShieldControl : new ShieldControlComponent(), 
                                LibraryComputer : new LibraryComputerComponent()
                            }

        this.hitNoShields = false;
        this.dockStarbase = null;
        this.sensorHistory = new SensorHistory();
        this.components.ShortRangeSensors.generateCorruptGrid();
    }

    // called on navigation
    autoRepairComponents()
    {
        for (var key in this.components)
        {
            let oldHealth = this.components[key].componentHealth;
            this.components[key].componentHealth += (randomInt(Enterprise.MinComponentRepairPerTurn, Enterprise.MaxComponentRepairPerTurn) / 100);
            this.components[key].componentHealth = Math.min(this.components[key].componentHealth, 1.0);

            if (this.components[key].componentHealth == 1.0 && oldHealth != 1.0)
            {
                gameOutputAppend("\n" + this.components[key].componentName + " fully repaired!");
            }
        }
    }

    repairRandomComponent()
    {
        var damagedComponents = [];

        for (var key in this.components)
        {
            if (this.components[key].componentHealth != 1.0)
            {
                damagedComponents.push(this.components[key]);
            }
        }

        console.log("Enterprise has " + damagedComponents.length + " damaged components");

        if (!damagedComponents.length)return;

        let componentToRepair = damagedComponents[randomInt(0, damagedComponents.length-1)];
        componentToRepair.componentHealth = 1.0;

        gameOutputAppend("\n"+componentToRepair.componentName + " has been fully repaired!");
    }

    undock(starbase)
    {
        this.dockStarbase = null;
    }

    dockWithStarbase(starbase)
    {
        console.log("dock with starbase");

        this.torpedoes = Enterprise.StartTorpedoes;
        this.freeEnergy = Enterprise.StartEnergy - this.shields;
        this.dockStarbase = starbase;

        gameOutputAppend("\nDocked with starbase.  Torpedoes and energy replenished.  The starbase's shields protect the Enterprise.");

        this.repairRandomComponent();
    }

    // is our total energy less than the minimum energy cost to get anywhere?
    isStranded()
    {
        return (this.freeEnergy + this.shields) < this.warpEnergyCost(1); // energy cost to travel one square.
    }

    isDestroyed()
    {
        return this.hitNoShields;
    }

    // suggested minimum shield level for the current battlefield, to survive at least one round of enemy fire
    suggestedMinShieldLevel(enemyList)
    {
        let possibleDamageSum = 0.0;

        for (var x in enemyList)
        {
            possibleDamageSum += enemyList[x].maxPhaserDamage();
        }

        return possibleDamageSum;
    }

    // is it possible for a single round of enemy fire to destroy the enterprise?
    isShieldLevelCritical(enemyList)
    {
        return !this.dockStarbase && (this.shields < this.suggestedMinShieldLevel(enemyList));
    }

    warpEnergyCost(numSectors)
    {
        return Enterprise.EnergyCostPerSector * numSectors;
    }
    
    // assumes that the input value has been previously checked for the appropriate range and available value
    setShieldLevel(newShields)
    {
        if ((newShields > this.freeEnergy + this.shields) || newShields < 0.0)
        {
            throw "Invalid value for shield level"; 
        }

        let adjustedShields = Math.min(this.components.ShieldControl.maxShields(), newShields);

        if (!(adjustedShields >0))
        {
            gameOutputAppend("Sorry captain, we've taken too much damage to raise shields!");
        }
        if ((adjustedShields < newShields) && (adjustedShields < ShieldControlComponent.MaxShields))
        {
            gameOutputAppend("\mBecause of damage to the deflector shields, we cannot raise shields above " + adjustedShields);
            newShields = adjustedShields;
        }

        this.freeEnergy += this.shields - newShields;
        this.shields = newShields;

        gameOutputAppend("\nShields set to " + this.shields + ".  " + this.freeEnergy + " free energy remaining.");
    }

    toString()
    {
        return "<*>";
    }

    static maxInstancesGame()
    {
        return 1;
    }

    static maxInstancesQuadrant()
    {
        return 1;
    }

    static minInstancesGame()
    {
        return 1;
    }

    conditionString(game)
    {
        if (game.currentQuadrant.countEntitiesOfType(Klingon))
        {
            return "RED";
        }

        if ((this.freeEnergy + this.shields) < .1 * Enterprise.StartEnergy)
        {
            return "YELLOW";
        }

        return "GREEN";
    }

    passthroughDamage(energy)
    {
        // we want to map (as a starting guess, pre balance) 500 energy to a total wipeout of a component
        let passthroughDamage = energy * randomFloat(.001, .002);

        // random component index
        let idx = randomWithProbabilities(this.componentDamageProbabilities());

        let component = this.components[Object.keys(this.components)[idx]];

        component.passthroughDamage(this, passthroughDamage);

        gameOutputAppend(component.componentName + " hit.  Now at " + Math.floor(component.componentHealth*100) + "% integrity" );
    }

    onPhaserHit(energy, game)
    {
        if (this.dockStarbase)
        {
            gameOutputAppend("The starbase shields protect you from the incoming phaser fire.");
            return;
        }

        let hitRatio = energy / this.shields;

        if (this.shields < energy)
        {
            this.hitNoShields = true;
            this.shields = 0.0;

            return;
        }

        if ((hitRatio > Enterprise.DamagePassthroughRatio) || Math.random() < Enterprise.RandomPassthroughRatio)
        {
            this.passthroughDamage(energy);
        }

        this.shields -= energy;
        gameOutputAppend("Shields at " + this.shields);
    }

    firePhasers(energy, game)
    {
        console.log("fire phasers");

        let targets = [];

        var x;
        for (x in Enterprise.PhaserTargets)
        {
            targets.push(...game.currentQuadrant.getEntitiesOfType(Enterprise.PhaserTargets[x]));
        }

        let enterprise = this;
        let targetsFiltered = targets.filter(function(item){return enterprise.canSeeEntity(item)});

        console.assert(energy <= this.freeEnergy);

        if (!targetsFiltered.length)
        {
            gameOutputAppend("\nUnable to lock phasers onto targets because of sensor damage!");
            return false;
        }

        this.freeEnergy -= energy;

        let endstr = targetsFiltered.length > 1 ? "s." : ".";
        gameOutputAppend("\nFiring phasers at " + targetsFiltered.length + " target" + endstr);
        
        let invisibleEnemies = targets.length - targetsFiltered.length;
        if (invisibleEnemies > 1)
        {
            gameOutputAppend("" + invisibleEnemies + " enemies not able to be targeted due to sensor damage!");
        }
        else if (invisibleEnemies == 1)
        {
            gameOutputAppend("" + 1 + " enemy not able to be targeted due to sensor damage!");
        }
      
        let damagePerTarget = energy / targetsFiltered.length;

        var x;
        for (x in targetsFiltered)
        {
            console.log("target");
            let target = targetsFiltered[x];
            let dist = this.distanceToObject(target);

            let damageAttenuated = damagePerTarget / dist;
            let damageFinal = Math.floor(randomFloat(2.0, 3.0) * damageAttenuated);

            if (this.components.PhaserControl.isHit())
            {
               target.onPhaserHit(damageFinal, game);
            }
            else
            {
                gameOutputAppend("Phasers miss!");
            }
        }

        if (!game.currentQuadrantScanned)
        {
            gameOutputAppend("\nRun combat sensor scan to see enemy shield levels.");
        }

        return true;
    }

    fireTorpedo(game, target)
    {
        if (this.freeEnergy >= Enterprise.TorpedoEnergyCost)
        {
            gameOutputAppend("\nFiring torpedoes towards subsector " + target.sectorString());
            let torpedoIntersection = game.currentQuadrant.intersectionTest(this.sectorX, this.sectorY, target.sectorX, target.sectorY, Infinity);
            this.torpedoes--;
            this.freeEnergy -= Enterprise.TorpedoEnergyCost;
            
            if (this.components.PhotonTubes.isHit() && torpedoIntersection.intersects != null)
            {
               torpedoIntersection.intersects.onTorpedoHit(game);
            }
            else
            {
                gameOutputAppend("\nThe torpedo missed!");
            }
        }
        else
        {
            //not enough energy
            gameOutputAppend("\nNot enough energy to fire torpedoes!");
        }
    }

    lrsStringEntityType(galaxyMap, entityType)
    {
        let header = "   ";
        for (let x = this.quadrantX - 1; x <= this.quadrantX + 1; x++)
        {
            header += padStringToLength((""+(x+1)), 6);
        }

        let border = "-------------------";
        let rval = header + "\n   " + border + '\n';

        for (let y = this.quadrantY - 1; y <= this.quadrantY + 1; y++)
        {
            rval += " " + (y+1) + " |";
            for (let x = this.quadrantX - 1; x <= this.quadrantX + 1; x++)
            {
                let quadrant = galaxyMap.lookup(x, y);
                if (quadrant)
                {
                    let k = quadrant.countEntitiesOfType(entityType);

                    if (x == this.quadrantX && y == this.quadrantY)
                    {
                        k = "" + k + "E";
                    }

                    rval += " " + padStringToLength(""+k, 3) + " |";
                }
                else
                {
                    rval += " *** |";
                }
            }
            rval += "\n   " + border + "\n";
        }
        return rval;
    }

    // long range scan
    lrsString(galaxyMap)
    {
        let rval = "\t KLINGONS\t\t  STARS\t\t\tSTARBASES\n";

        let klingonLRS = this.lrsStringEntityType(galaxyMap, Klingon);
        let starLRS = this.lrsStringEntityType(galaxyMap, Star);
        let starbaseLRS = this.lrsStringEntityType(galaxyMap, StarBase);

        let klingonLRSLines = klingonLRS.split('\n');
        let starLRSLines = starLRS.split('\n');
        let starbaseLRSLines = starbaseLRS.split('\n');

        console.assert(klingonLRSLines.length == starLRSLines.length);
        for (var x in klingonLRSLines)
        {
            rval += klingonLRSLines[x] + "\t" + starLRSLines[x] + "\t" + starbaseLRSLines[x] + '\n';
        }

        return rval;
    }

    warp(sectorXEnd, sectorYEnd, sectorsToTravel, game)
    {
        let energyRequired = this.warpEnergyCost(sectorsToTravel);

        if (this.freeEnergy < energyRequired)
        {
            gameOutputAppend("\nNot enough energy free to complete maneuver!");
            return false;
        }

        let intersection = game.currentQuadrant.intersectionTest(this.sectorX, this.sectorY, sectorXEnd, sectorYEnd)
           
        this.sectorX = Math.floor(intersection.lastX);
        this.sectorY = Math.floor(intersection.lastY);

        if (intersection.intersects != null)
        {
            gameOutputAppend("\nObstruction ahead.  Shutting down warp engines.");
        }

        if (!intersection.stepIterations)
        {
            return false;
        }

        let actualEnergy = this.warpEnergyCost(intersection.stepIterations);

        // get the energy cost of the sectors we actually travelled
        this.freeEnergy -= actualEnergy;

        return true;
    }

    damageReport()
    {
        if (!this.components.LibraryComputer.damageReportAvailable())
        {
            gameOutputAppend("\nDamage report unavailable due to computer damage!");
            return;
        }

        gameOutputAppend("\nDAMAGE REPORT:\n");
        gameOutputAppend("Component Integrity:")
        for (var key in this.components)
        {
            let component = this.components[key];
            gameOutputAppend("" + component.componentName + " : " + Math.round(component.componentHealth * 100) + "%");
        }

        gameOutputAppend("\n\nNOTES:\nRepair crews can repair 1-5% damage per stardate.  A starbase will fully repair a single component every stardate.");

        for (var key in this.components)
        {
            let component = this.components[key];
            component.damageReport();
        }
    }
}

Enterprise.StartTorpedoes = 10;
Enterprise.StartEnergy = 3000;
Enterprise.StartShields = 0;
Enterprise.TorpedoEnergyCost = 10;
Enterprise.EnemyScanCost = 10;
Enterprise.PhaserTargets = [Klingon];           // future extension : this list could be dynamic based on evolving gameplay alliances, etc :) 
Enterprise.EnergyCostPerSector = 1.0;           // Warp cost per sector moved
Enterprise.EnergyCostPerQuadrant = 10.0;        // Warp cost per quadrant moved
Enterprise.DamagePassthroughRatio = .25;        // if damage is 25% of shields or more, pass damage through to components
Enterprise.RandomPassthroughRatio = .25;        // 25% chance that damage will pass through to ship components regardless of shields
Enterprise.MinComponentRepairPerTurn = 1;       // integrity min autorepair per component
Enterprise.MaxComponentRepairPerTurn = 5;       // integrity max autorepair per component


// ------- Quadrant.js ------- 
class Quadrant
{
    constructor(widthSectorsIn, heightSectorsIn, x, y)
    {
        checkArgumentsDefinedAndHaveValue(arguments);
        this.width = widthSectorsIn;
        this.height = heightSectorsIn;
        this.quadrantEntities = new Array();
        this.x = x;
        this.y = y;
    }

    populateFromJSData(entitiesQuadrantJS)
    {
        var x;
        for (x in entitiesQuadrantJS.quadrantEntities)
        {
            let entData = entitiesQuadrantJS.quadrantEntities[x];

            // we construct and insert the enterprise entity elsewhere.
            if (entData.entityType != "Enterprise")
            {
                let ctype = EntityMap.get(entData.entityType);

                let entityObj = new ctype(); 
                Object.assign(entityObj, entData);

                this.quadrantEntities.push(entityObj);
            }
        }
    }

    removeEntity(entity)
    {
        let rmindex = this.quadrantEntities.indexOf(entity);
        if (rmindex == -1)throw "Entity not found";
        this.quadrantEntities.splice( rmindex, 1 );
    }

    entityAtLocation(nextXCoord, nextYCoord)
    {
        nextXCoord = Math.floor(nextXCoord);
        nextYCoord = Math.floor(nextYCoord);
        
        for (var x in this.quadrantEntities)
        {
            let objTest = this.quadrantEntities[x];

            if ((objTest.sectorX == nextXCoord) && (objTest.sectorY == nextYCoord))
            {
                return objTest;
            }
        }

        return null;
    }

    // return a tuple containing
    // the last sector prior to the intersection
    // and the intersection object (null if none)
    intersectionTest(sectorX, sectorY, sectorXEnd, sectorYEnd, maxT = 1.0)
    {
        checkArgumentsDefinedAndHaveValue(arguments);

        // polar to euclidean coordinates
        let xVec = sectorXEnd - sectorX;
        let yVec = sectorYEnd - sectorY;

        // we'll step through the grid in in increments of one cell; -1 if the x / y direction are negative
        let xNextF = xVec > 0.0 ? 1.0 : -1.0;
        let yNextF = yVec > 0.0 ? 1.0 : -1.0;

        // start in the middle of the cell.
        let startCoordX = Math.floor(sectorX) + .5;
        let startCoordY = Math.floor(sectorY) + .5;
        let endCoordX = Math.floor(sectorXEnd) + .5;
        let endCoordY = Math.floor(sectorYEnd) + .5;

        // return values
        let lastCellBeforeIntersectionX = startCoordX;
        let lastCellBeforeIntersectionY = startCoordY;
        let intersectionObject = null;

        //console.log("start coord " + (startCoordX) + " " + (startCoordY));
        //console.log("end coord " + (endCoordX) + " " + (endCoordY));
        //console.log("vec " + (xVec) + " " + (yVec));

        var nextXCoord = 0;
        var nextYCoord = 0;

        let currentT = 0.0;

        var steps = 0;
        while (true)
        {
            // we have, given a start coordinate and a direction vector, the parametric equation of a line
            // Pt = P0 + D*t
            // From this we can derive the parameter t at which the line will reach a particular X or Y value
            // X_t = X_0 + V_x * t
            // Y_t = Y_0 + V_y * t
            // implies
            // (X_t - X_0) / V_x = t
            // or
            // (Y_t - Y_0) / V_y = t
            // so we can figure out what the next cell on the x axis is (current plus or minus one) and figure
            // out the t parameter where the line crosses it.  
            // We can do the same for the next call on the y axis.
            // Then, whichever cell has the lower t parameter the line crosses first.
            // Because there's a division and it's possible the direction vector has a zero component, we'll check for divide by zero

            nextXCoord = Math.floor(lastCellBeforeIntersectionX + xNextF);
            nextYCoord = Math.floor(lastCellBeforeIntersectionY + yNextF);

            //console.log("next " + nextXCoord + " " + nextYCoord);

            let tXBound = ((nextXCoord+.5) - startCoordX) / xVec;
            let tYBound = ((nextYCoord+.5) - startCoordY) / yVec;

            tXBound = Math.abs(xVec) > .00001 ?  tXBound : Number.MAX_VALUE;
            tYBound = Math.abs(yVec) > .00001 ?  tYBound : Number.MAX_VALUE;

            if (tXBound < tYBound) // hit the x boundary first.
            {
                //console.log("xb " + tXBound);
                currentT = tXBound;
                nextYCoord = startCoordY + yVec * currentT;
            }
            else
            {
                //console.log("yb");
                currentT = tYBound;
                nextXCoord = startCoordX + xVec * currentT;
            }

            if (currentT > maxT)
            {
                //console.log("Exceeded jump range "+ currentT);
                break;
            }

            intersectionObject = this.entityAtLocation(nextXCoord, nextYCoord);

            if (intersectionObject != null)
            {
                //console.log("intersection return");
                break;
            }

            if (nextXCoord < 0 || nextXCoord >= quadrantWidthSectors || nextYCoord < 0 || nextYCoord >= quadrantHeightSectors)
            {
                //console.log("next out of bounds " + nextXCoord + " " + nextYCoord);
                break;
            }

            //console.log("T is at " + currentT);
            lastCellBeforeIntersectionX = nextXCoord;
            lastCellBeforeIntersectionY = nextYCoord;

            steps++;

            //console.log("cell step" + (lastCellBeforeIntersectionX) + " " + (lastCellBeforeIntersectionY));
        }

        //console.log("cell end " + (lastCellBeforeIntersectionX) + " " + (lastCellBeforeIntersectionY)+ " " + intersectionObject);
        return {lastX : lastCellBeforeIntersectionX, lastY : lastCellBeforeIntersectionY, intersects : intersectionObject, stepIterations:steps, nextX : nextXCoord, nextY : nextYCoord};
    }

    countEntitiesOfType(classtype)
    {
        var rval=0;
        for (var x in this.quadrantEntities)
        {
            if (this.quadrantEntities[x].constructor == classtype)
            {
                rval++;
            }
        }
        return rval;
    }

    getEntitiesOfType(classtype)
    {
        return this.quadrantEntities.filter(function(item){return item.constructor == classtype});
    }

    getAdjacentEntitiesOfType(adjacentToObj, classtype)
    {
        let sblist = this.getEntitiesOfType(classtype);
        return sblist.filter(function(sb){return sb.isAdjacentTo(adjacentToObj)});
    }

    klingonsFire(target, game)
    {
        let klist = this.getEntitiesOfType(Klingon);

        if (klist.length > 1)
        {
            gameOutputAppend("\nThe Klingon vessels fire their phasers.");
        }
        else if (klist.length)
        {
            gameOutputAppend("\nThe Klingon vessel fires its phasers.");
        }

        for (var x in klist)
        {
            klist[x].firePhasers(target, game);
        }
    }

    createEntities(entityTypes)
    {
        var entityIdx;
        for (entityIdx in entityTypes)
        {
            let entityType = entityTypes[entityIdx];

            let numEntities = entityType.randomCountForQuadrant(this.emptySquares(), this.countEntitiesOfType(entityType));

            for (let i =0; i < numEntities; i++ )
            {
                var ent = new entityType();
                this.addEntityInFreeSector(ent);
            }
        }
    }

    addEntityInFreeSector(entity)
    {
        entity.quadrantX = this.x;
        entity.quadrantY = this.y;
        entity.setLocationSector(this.getEmptySquare());
        this.quadrantEntities.push(entity);
    }

    addEntity(entity)
    {
        entity.quadrantX = this.x;
        entity.quadrantY = this.y;

        this.quadrantEntities.push(entity);
    }

    emptySquares()
    {
        return this.width*this.height - this.quadrantEntities.length;
    }

    getEmptySquare()
    {
        console.assert(this.width * this.height > this.quadrantEntities.length);

        if (this.quadrantEntities.length >= this.width*this.height)
        {
            return null;
        }

        let emptyFound = false;

        let testRandom = randomInt(0, (this.width*this.height)-1);

        while (!emptyFound)
        {
            let randomX = testRandom % this.width;
            let randomY = Math.floor(testRandom / this.height);

            var entityIdx;
            emptyFound = true;
            for (entityIdx in this.quadrantEntities)
            {
                let entity = this.quadrantEntities[entityIdx];
                if (entity.sectorX == randomX && entity.sectorY == randomY)
                {
                    emptyFound = false;
                    break;
                }
            }

            if (emptyFound)
            {
                return {x : randomX, y : randomY};
            }

            testRandom++;
        }
    }

    toString()
    {
        let borderStringPost = "   " + mapFooter(quadrantWidthSectors) + '\n';
        let borderStringPre = "   " + mapHeader(quadrantWidthSectors); 

        let quadrantStringGrid = new Grid(this.width, this.height, function(){return " ".padStart(sectorDisplayWidthChars, ' ')})

        var gameObjectIndex;
        for (gameObjectIndex in this.quadrantEntities)
        {
            let gameObject = this.quadrantEntities[gameObjectIndex];
            let objStr = gameObject.toString().padStart(sectorDisplayWidthChars, ' ');
            quadrantStringGrid.setValue(gameObject.sectorX, gameObject.sectorY, objStr);
        }

        let mapString = quadrantStringGrid.toString();

        return "<pre>" + borderStringPre + mapString + borderStringPost + "</pre>";
    }
}

// ------- GalaxyMap.js ------- 
class GalaxyMap extends Grid
{
    constructor(quadrantsX, quadrantsY, entityTypes)
    {
        checkArgumentsDefinedAndHaveValue(arguments);
        super(quadrantsX, quadrantsY, function(x, y){return new Quadrant(quadrantWidthSectors,quadrantHeightSectors, x, y)});

        this.createMinimumInstances(entityTypes, quadrantsX, quadrantsY);

        for (let i = 0; i < quadrantsX*quadrantsY; i++)
        {
            this.lookup1D(i).createEntities(entityTypes);
        }
    }

    static ConstructFromJSData(jsData)
    {
        let rval = new GalaxyMap(mapWidthQuadrants, mapHeightQuadrants, []);

        var x;
        for (x in jsData.contents)
        {
            let entitiesQuadrantJS = jsData.contents[x];

            rval.contents[x].populateFromJSData(entitiesQuadrantJS);
        }

        return rval;
    }

    mapString(galaxyMap, EntityType = Klingon, gameobject = null)
    {
        let header = "   ";
        for (let x = 0; x < mapWidthQuadrants; x++)
        {
            header += padStringToLength((""+(x+1)), 6);
        }

        let border = "------";
        border = border.repeat(mapWidthQuadrants);
        let rval = header + "\n   " + border + '\n';

        for (let y = 0; y < mapHeightQuadrants; y++)
        {
            rval += " " + (y+1) + " |";
            for (let x = 0; x < mapWidthQuadrants; x++)
            {
                let quadrant = galaxyMap.lookup(x, y);
                
                if (quadrant)
                {    
                    let k = quadrant.countEntitiesOfType(EntityType);

                    if (gameobject)
                    {
                        if (gameobject.quadrantX == x && gameobject.quadrantY == y)
                        {
                            // put an "E" on the map for the enterprise's current location
                            k += 'E';
                        }
                    }

                    rval += " " + padStringToLength(""+k, 3, ' ') + " |";
                }
                else
                {  console.log(" null");
                    rval += " *** |";
                }
             }
             rval += "\n   " + border + "\n";
         }
         return rval;
    }

    createMinimumInstances(entityTypes)
    {
        var x;
        for (x in entityTypes)
        {
            let etype = entityTypes[x];

            let instancesToCreate = etype.minInstancesGame() ;//- etype.Instances;

            // console.log("Creating min instances of " + etype.name + " : " + instancesToCreate);
            if (instancesToCreate > 0)
            {
                for (let i = 0; i < instancesToCreate; i++)
                {
                    let inst = new etype();
                    let randomQuadrant = randomInt(0, this.contents.length-1);

                    let instAssigned = false;
                    for (let quad = 0; quad < this.contents.length; quad++)
                    {
                        if (this.lookup1D(randomQuadrant).emptySquares())
                        {
                            this.lookup1D(randomQuadrant).addEntityInFreeSector(inst);
                            instAssigned = true;
                            break;
                        }

                        randomQuadrant = (randomQuadrant + 1 ) % this.contents.length;
                    }
                    
                    if (!instAssigned)
                    {
                        throw "Not enough space to assign minumum instances of " + etype.name;
                    }
                }
            }
        }
    }
}

// ------- SensorHistory.js ------- 
class SensorHistory extends Grid
{
    constructor()
    {
        super( mapWidthQuadrants, mapHeightQuadrants, function(){return {};} );
    }

    updateSensorHistory(EntityType, galaxyMap, startLocX, startLocY, endLocX, endLocY)
    {
        for (var y = startLocY; y <= endLocY; y++)
        {
            for (var x = startLocX; x <= endLocX; x++)
            {
                let quadrant = galaxyMap.lookup(x, y);

                if (quadrant)
                {
                    let ct = quadrant.countEntitiesOfType(EntityType);
                    this.lookup(x, y)[EntityType] = ct;
                }
            }
        }               
    }

    updateSensorHistoryForEntityTypes(EntityList, galaxyMap, startLocX, startLocY, endLocX, endLocY)
    {
        for (var x in EntityList)
        {
            let EntityType = EntityList[x];
            this.updateSensorHistory(EntityType, galaxyMap, startLocX, startLocY, endLocX, endLocY);
        }
    }

    mapString(EntityType = Klingon, gameobject = null)
    {
        let header = "   ";
        for (let x = 0; x < mapWidthQuadrants; x++)
        {
            header += padStringToLength((""+(x+1)), 6);
        }

        let border = "------";
        border = border.repeat(mapWidthQuadrants);
        let rval = header + "\n   " + border + '\n';

        for (let y = 0; y < this.height; y++)
        {
            rval += " " + (y+1) + " |";
            for (let x = 0; x < this.width; x++)
            {
                let quadrantDict = this.lookup(x, y);
                
                if (quadrantDict)
                {    
                    var k = "";

                    if (EntityType in quadrantDict)
                    {
                        k += quadrantDict[EntityType]; // integer count of the entity type
                    }
                    else
                    {
                        k += "?";
                    }

                    if (gameobject)
                    {
                        if (gameobject.quadrantX == x && gameobject.quadrantY == y)
                        {
                            // put an "E" on the map for the enterprise's current location
                            k += 'E';
                        }
                    }

                    rval += " " + padStringToLength(""+k, 3, ' ') + " |";
                }
                else
                {  console.log(" null");
                    rval += " *** |";
                }
             }
             rval += "\n   " + border + "\n";
         }
         return rval;
     }
}

// ------- Menu.js ------- 
class MenuOption
{
    constructor(option, separator, description, payload)
    {
        this.option = option.toString();
        this.separator = separator;
        this.description = description;
        this.payload = payload;
        this.enabled = true;
    }

    compare(testString)
    {
        return testString.toLowerCase() == this.option.toLowerCase();
    }

    toString()
    {
        return this.option + this.separator + this.description + '\n';
    }
}

class Menu
{
    constructor()
    {
        this.options = [];
    }

    getSelectedOption(optionText)
    {
        for (var x in this.options)
        {
            if (this.options[x].compare(optionText))
            {
                return this.options[x];
            }
        }
        return null;
    }

    invalidOption()
    {
        gameOutputAppend("Come again, captain?");
        return false;
    }

    chooseOption(optionText)
    {
        var menuopt = this.getSelectedOption(optionText);
        if (menuopt)
        {
            return menuopt.payload();
        }
        return this.invalidOption(optionText);
    }

    toString()
    {
        var rstring = "ENTER ONE OF THE FOLLOWING:\n";

        for (var x in this.options)
        {
            if (this.options[x].enabled)
            {
                rstring += this.options[x];
            }
        }

        return rstring;
    }
}


// ------- MainMenu.js ------- 
class MainMenu extends Menu
{
    constructor(trekgame)
    {
        super();

        this.options = [];

        this.options.push
        (
            new MenuOption
            (
                "0",
                ") ",
                "DOCK WITH STARBASE",
                function()
                {
                    let adjacentStarbases = trekgame.currentQuadrant.getAdjacentEntitiesOfType(trekgame.enterprise, StarBase);
                    console.assert(adjacentStarbases.length);

                    let sb = adjacentStarbases[0];

                    trekgame.enterprise.dockWithStarbase(sb);

                    trekgame.showDockMenu(sb);

                    trekgame.advanceStardate(1.0);

                    return false;
                }
            ),
            new MenuOption
            (
                "1",
                ") ",
                "NAVIGATION",
                function()
                {
                    let navigationMenu = new Menu();
                    navigationMenu.options.push
                    (
                        new MenuOption
                        (
                            "1",
                            ") ",
                            "SHORT RANGE JUMP (1 STARDATE)",
                            function()
                            {
                                trekgame.getSubsectorMenu(trekgame.shortRangeNavigationHandler);
                                return false;
                            }
                        ),
                        new MenuOption
                        (
                            "2",
                            ") ",
                            "LONG RANGE JUMP  (1 STARDATE)",
                            function()
                            {
                                trekgame.awaitInput("Enter destination sector X coordinate. Enter a value between 1 and " + mapWidthQuadrants, 2, trekgame.navigationHandlerLongRangeX);
                                return false;
                            }
                        ),
                        new MenuOption
                        (
                            "3", ") ", "BACK", function(){return true;}
                        )
                    );

                    trekgame.awaitInput(navigationMenu.toString(), 1, function(inputline){return navigationMenu.chooseOption(inputline);});

                    //trekgame.awaitInput("Enter heading (degrees).", 3, trekgame.navigationHandler);
                }
            ), 

            new MenuOption
            (
                "2", ") ", "WEAPONS",
                function()
                {
                    MainMenu.showWeaponsMenu(trekgame);
                }
            ),

            new MenuOption
            (
                "3",
                ") ",
                "SHIELD CONTROL",
                function()
                {
                    let totalEnergy = (trekgame.enterprise.freeEnergy + trekgame.enterprise.shields);
                    
                    let suggestedStr = "";
                    if (trekgame.currentQuadrant.countEntitiesOfType(Klingon))
                    {
                        let klingonList = trekgame.currentQuadrant.getEntitiesOfType(Klingon);

                        let suggestedShieldLevel = trekgame.enterprise.suggestedMinShieldLevel(klingonList);

                        suggestedStr += "\nSUGGESTED SHIELD LEVEL FOR CURRENT COMBAT SITUATION: " + suggestedShieldLevel;
                    }

                    let maxStr = "\nMAXIMUM SHIELD ENERGY: " + trekgame.enterprise.components.ShieldControl.maxShields();

                    trekgame.awaitInput("ENTER NEW SHIELD ENERGY LEVEL. \nAVAILABLE ENERGY: " + totalEnergy + maxStr + suggestedStr, 4, trekgame.shieldHandler);
                }
            ),

            new MenuOption
            (
                "4",
                ") ",
                "SENSORS",
                function()
                {
                    let enemyScanAddendum = trekgame.currentQuadrantScanned ? "" : " (" + Enterprise.EnemyScanCost + " ENERGY)";
                    let sensorMenu = new Menu();

                    sensorMenu.options.push
                    (
                        new MenuOption("1", ") ", "SCAN ENEMY SHIPS" + enemyScanAddendum, function(){trekgame.scanEnemyShips(); return true;}),
                        new MenuOption("2", ") ", "LONG RANGE SENSORS (1 STARDATE)", function(){trekgame.longRangeScan(); return true;}),
                        new MenuOption("3", ") ", "BACK", function(){return true;})
                    );

                    return trekgame.awaitInput(sensorMenu.toString(), 1, function(inputline){return sensorMenu.chooseOption(inputline);});
                }
            ),

            new MenuOption
            (
                "5",
                ") ",
                "SHIP'S COMPUTER",
                function()
                {
                    return trekgame.awaitInput(trekgame.computerMenu.toString(), 1, function(inputline){return trekgame.computerMenu.chooseOption(inputline);});
                }
            )
        );

        this.dockOption = this.options[0];
        this.dockOption.enabled = false;
    }

    static showWeaponsMenu(trekgame)
    {
        var weaponsMenu = new Menu();

        weaponsMenu.options.push(
        new MenuOption
            (
                "1",
                ") ",
                "PHASERS",
                function()
                {
                    if (!trekgame.enterprise.components.PhotonTubes.canFire())
                    {
                        gameOutputAppend("\nPhasers too damaged to fire!");
                        return true;
                    }
                    if (trekgame.currentQuadrant.countEntitiesOfType(Klingon))
                    {
                        let freestring = "\nFREE ENERGY : " + trekgame.enterprise.freeEnergy;
                        
                        let accuracy = trekgame.enterprise.components.PhaserControl.phaserAccuracy() * 100;
                        let chanceToHitString = "PHASER CHANCE TO HIT : " + accuracy + "%";
                        
                        trekgame.awaitInput(chanceToHitString + "\nENTER ENERGY TO EXPEND ON PHASER FIRE"+freestring, 4, trekgame.phaserHandler);
                        return false;
                    }
                    else
                    {
                        gameOutputAppend("\nPhaser control : No enemies detected in this sector, captain.");
                        return true;
                    }
                }
            ),

            new MenuOption
            (
                "2",
                ") ",
                "PHOTON TORPEDOES ("+Enterprise.TorpedoEnergyCost+" ENERGY)",
                function()
                {
                    if (trekgame.enterprise.torpedoes <= 0)
                    {
                        gameOutputAppend("\nWe're out of torpedoes, captain!");
                    }
                    else if (trekgame.enterprise.components.PhotonTubes.canFire())
                    {
                        if (trekgame.enterprise.components.PhotonTubes.targetingAvailable())
                        {
                            // automatic targeting enabled. push a menu of targets.
                            console.log("auto targeting path");

                            let torpMenu = new TorpedoMenu(trekgame.currentQuadrant.getEntitiesOfType(Klingon), trekgame);

                            trekgame.awaitInput(torpMenu.toString(), 1, function(inputline){return torpMenu.chooseOption(inputline);});
                        }
                        else
                        {
                            gameOutputAppend("\nDue to damage, torpedo targeting computer is nonfunctional.");
                            gameOutputAppend("You will have to enter the torpedo destination coordinates manually!");
                            trekgame.manualTorpedoHandler();
                        }
                    }
                    else
                    {
                        gameOutputAppend("Torpedo tubes too damaged to fire!");
                    }
                }
            ),

            new MenuOption("3", ") ", "BACK", function(){return true;})

        );

        return trekgame.awaitInput(weaponsMenu.toString(), 1, function(inputline){return weaponsMenu.chooseOption(inputline);});
    }

}



// ------- TorpedoMenu.js ------- 
class TorpedoMenu extends Menu
{
    constructor(targetList, trekgame)
    {
        super();

        this.options = [];

        for (var x = 0; x < targetList.length; x++)
        {
            let tgt = targetList[x];

            if (trekgame.enterprise.canSeeEntity(tgt))
            {
                this.options.push
                (
                    new MenuOption
                    (
                        x + 1,
                        ") ",
                        "TARGET AT SUBSECTOR ("+targetList[x].sectorString() + ")",
                        function()
                        {
                            trekgame.torpedoHandler(tgt);
                            return true;
                        }
                    )
                );
            }
            else
            {
                this.options.push
                (
                    new MenuOption
                    (
                        x + 1,
                        ") ",
                        "???????#####?#??#???#??#??????????",
                        function()
                        {
                            gameOutputAppend("\nUnable to lock on to target due to short range sensor damage");
                            return true;
                        }
                    )
                );
            }
        }

        this.options.push
        (
            new MenuOption
            (
                this.options.length + 1, 
                ") ",
                "MANUAL TARGETING (CHANCE TO HIT : " + (100 * trekgame.enterprise.components.PhotonTubes.torpedoAccuracy()) + "%)",
                function()
                {
                    trekgame.manualTorpedoHandler();
                }
            )
        );

        this.options.push
        (
            new MenuOption
            (
                this.options.length + 1, 
                ") ",
                "BACK",
                function()
                {
                    console.log("back button");
                    return true;
                }
            )
        );
    }
}

// ------- ShipComputer.js ------- 
class ShipComputerMenu extends Menu
{
    constructor(trekGame)
    {
        super();
        this.options = [];

        this.options.push(

            new MenuOption
            (
                "1",
                ") ",
                "CAPTAIN'S MANUAL",
                function()
                {
                    trekGame.printTutorial();
                    return false;
                }
            ),

            new MenuOption
            (
                "2",
                ") ",
                "DAMAGE REPORT",
                function()
                {
                    trekGame.enterprise.damageReport();
                    return true;
                }
            ),

            new MenuOption
            (
                "3", ") ", "MAPS",
                function()
                {
                    ShipComputerMenu.showMapMenu(trekGame);
                    return false;
                }
            ),

            new MenuOption
            (
                "4",
                ") ",
                "SELF DESTRUCT",
                function()
                {
                    let resignMenu = new Menu();

                    resignMenu.options.push
                    (
                        new MenuOption("1", ") ", "END CURRENT GAME AND ERASE SAVE", function(){trekGame.endGame()}),
                        new MenuOption("2", ") ", "CANCEL", function(){return true})
                    );

                    trekGame.awaitInput(resignMenu.toString(), "1", function(inputLine){return resignMenu.chooseOption(inputLine);});
                    return;
                }
            ),

            new MenuOption
            (
                "5",
                ") ",
                "BACK",
                function()
                {
                    return true;
                }
            )

        );
    }

    static showMapMenu(trekGame)
    {
        let mapMenu = new Menu();

        mapMenu.options.push(
        new MenuOption
            (
                "1",
                ") ",
                "STARBASE MAP",
                function()
                {
                    if (!trekGame.enterprise.components.LibraryComputer.mapsAccessible())
                    {
                        gameOutputAppend("\nShip's computer too damaged to access maps.");
                        return true;
                    }

                    gameOutputAppend("\nFEDERATION STARBASES");
                    gameOutputAppend(trekGame.galaxyMap.mapString(trekGame.galaxyMap, StarBase, trekGame.enterprise));
                    return true;
                }
            ),

            new MenuOption
            (
                "2",
                ") ",
                "KLINGONS MAP",
                function()
                {
                    if (!trekGame.enterprise.components.LibraryComputer.mapsAccessible())
                    {
                        gameOutputAppend("\nShip's computer too damaged to access maps.");
                        return true;
                    }

                    gameOutputAppend("\nSENSOR RECORDS OF KLINGONS IN EACH SECTOR");
                    gameOutputAppend(trekGame.enterprise.sensorHistory.mapString(Klingon, trekGame.enterprise));
                    return true;
                }
            ),

            new MenuOption
            (
                "3",
                ") ",
                "STAR DENSITY MAP",
                function()
                {
                    if (!trekGame.enterprise.components.LibraryComputer.mapsAccessible())
                    {
                        gameOutputAppend("\nShip's computer too damaged to access maps.");
                        return true;
                    }
                    
                    gameOutputAppend("\nSENSOR RECORDS SHOWING NUMBER OF STARS IN EACH SECTOR");
                    gameOutputAppend(trekGame.enterprise.sensorHistory.mapString(Star, trekGame.enterprise));
                    return true;
                }
            ), 

            new MenuOption("4", ") ", "BACK", function(){return true;})
        );

        trekGame.awaitInput(mapMenu.toString(), "1", function(inputLine){return mapMenu.chooseOption(inputLine);});
    }
}

// ------- TrekGame.js ------- 
class TrekGame
{
    static ConstructFromJSData(jsData)
    {
        try
        {
            let gamerval = Object.create(TrekGame.prototype);
            Object.assign(gamerval, jsData);

            gamerval.enterprise = Object.create(Enterprise.prototype);
            Object.assign(gamerval.enterprise, jsData.enterprise);

            gamerval.enterprise.sensorHistory = new SensorHistory();// Object.create(SensorHistory);
            Object.assign(gamerval.enterprise.sensorHistory, jsData.enterprise.sensorHistory);

            gamerval.galaxyMap = GalaxyMap.ConstructFromJSData(jsData.galaxyMap);

            // console.log("galaxy map : " + gamerval.galaxyMap);

            gamerval.currentQuadrant = gamerval.galaxyMap.lookup(gamerval.enterprise.quadrantX, gamerval.enterprise.quadrantY);

            gamerval.currentQuadrant.addEntity(gamerval.enterprise);

            gamerval.createMenus();

            gamerval.checkStarbaseDock();

            if (gamerval.enterprise.dockStarbase)
            {
                gamerval.showDockMenu();
            }
            else
            {
                gamerval.setInputPrompt(gamerval.mainMenu.toString());
            }

            gamerval.updateDisplay();
            return gamerval;
        }
        catch(err)
        {
            console.log("Corrupt save file.  Erasing.");
            autosave(null);
            gameOutputAppend("Corrupt save file.  Refresh page to start new game.");
        }
    }

    constructor()
    {
        this.primeUniverse = true;

        if (!this.primeUniverse)
        {
            TrekGame.EntityTypes.push(Planet);
        }

        this.gameOver = false;

        this.galaxyMap = new GalaxyMap(mapWidthQuadrants, mapHeightQuadrants, TrekGame.EntityTypes);
        
        this.enterprise = new Enterprise();

        // start in a random quadrant
        this.enterprise.quadrantX = randomInt(0, mapWidthQuadrants - 1);
        this.enterprise.quadrantY = randomInt(0, mapHeightQuadrants - 1);
        this.enterprise.sectorX = 0;
        this.enterprise.sectorY = 0;
        
        this.currentQuadrant = this.galaxyMap.lookup(this.enterprise.quadrantX, this.enterprise.quadrantY);

        this.currentQuadrant.addEntityInFreeSector(this.enterprise);

        // pick a stardate between the start and end of TOS
        this.starDate = randomInt(1312, 5928);
        this.starDateBegin = this.starDate;
        this.endStarDate = this.starDate + TrekGame.BaseMissionTime + randomInt(0, TrekGame.MissionTimeSpread);

        this.currentQuadrantScanned = false;

        this.createMenus();
        this.setInputPrompt(this.mainMenu.toString());

        this.updateGame();

        this.printStory();

        autosave(this);
    }

    showDockMenu(sb)
    {
        let dockMenu = new Menu();
        let trekgame = this;

        dockMenu.options.push
        (
            new MenuOption
            (
                "1",
                ") ", 
                "STAY DOCKED (1 STARDATE, REPAIRS A COMPONENT)",
                function()
                {
                    trekgame.advanceStardate(1.0);
                    trekgame.enterprise.repairRandomComponent();
                    return false;
                }
            ),
            new MenuOption
            (
                "2",
                ") ",
                "UNDOCK",
                function()
                {
                    trekgame.enterprise.undock(sb);
                    gameOutputAppend("Undocking from starbase");

                    // explicitly doesn't take a stardate to do this action.

                    return true;
                }
            ),
            new MenuOption
            (
                "3", ") ", "DAMAGE REPORT", 
                function()
                {
                    trekgame.enterprise.damageReport();
                    return false;
                }
            ),
        );

        this.awaitInput
        (
            dockMenu.toString(),
            1,
            function(inputline){return dockMenu.chooseOption(inputline);}
        );
    }

    starbasesScan()
    {
        var sh = this.enterprise.sensorHistory;

        for (var x in StarBase.starbaseList)
        {
            let starbase = StarBase.starbaseList[x];
            sh.updateSensorHistoryForEntityTypes
            (
                [Star, Klingon], 
                this.galaxyMap, 
                starbase.quadrantX-1, 
                starbase.quadrantY-1, 
                starbase.quadrantX+1, 
                starbase.quadrantY+1
            );
        }
    }
    
    generateScore(gameWon)
    {
        let baseScore = 1000 * (Klingon.InstancesDestroyed / (1 + this.starDate - this.starDateBegin));
        let winMultiplier = 2.0;

        return gameWon ? Math.round(winMultiplier * baseScore) : Math.round(baseScore);
    }

    destroyKlingon(k)
    {
        gameOutputAppend("Klingon Fighter Destroyed");
        this.currentQuadrant.removeEntity(k);
        Klingon.Instances--;
        Klingon.InstancesDestroyed++;
    }

    printStory()
    {
        var storyString = "The stardate is " + this.starDate + ".\n\nYou are the captain of the USS Enterprise.  " +
        "You have received word from Starfleet command of a plot by Klingon spies to destroy all the Federation " +
        "starbases in the region so the Klingon Empire can assume control.\n\n";

        storyString += 
        "The Federation is in danger and you are the only ship in range.\n\n"

        storyString+= 
        "Your mission is to hunt down and destroy the " + Klingon.Instances + " Klingon warships in the region.\n" + 
        "You must complete your mission before stardate " + this.endStarDate + ", giving you " + (this.endStarDate - this.starDate) + 
        " stardates to succeed.";

        storyString += 
        "\n\nThere are " + StarBase.Instances + " Federation Starbases in the region for refueling, restocking torpedoes, and repairs.";

        storyString += "\n\nCheck the ship's computer to access the captain's manual for a tutorial on how to complete your mission.";

        storyString += "\n\nGood luck, galactic peace is in your hands!";

        gameOutputAppend(storyString);
    }

    printTutorial()
    {
        let tutorialMenu = new Menu();

        let trekGame = this;

        tutorialMenu.options.push
        (
            new MenuOption
            (
                "1", ") ", "TUTORIAL: MAIN DISPLAY",
                function()
                {
                    let tutorialString = "";

                    tutorialString += "DISPLAY:\nThe map display at the top of your screen shows the map of the galactic sector where your ship is located.  ";
                    tutorialString += "Your mission takes place in a region of the galaxy that is " + mapWidthQuadrants + " by " + mapHeightQuadrants + " sectors.";
                    tutorialString += "  A galactic sector is about 2 light years across.";

                    tutorialString += "\n\nThe sector map is made up of a grid of subsectors.  The X,Y coordinates of the subsectors are displayed across the horizontal and vertical axes of the map.  The key symbols corresponding to different objects occupying a subsector are listed below.";

                    tutorialString += "\n\nTo the right of the map screen are important stats about your mission, your ship's status, and your ship's location. ";

                    tutorialString += "\n\nBelow the map screen are important status flags, such as whether the shields are too low or whether we're at red alert when enemies are present. ";

                    tutorialString += "\n\nMap key :\n" +
                    "<*> : ENTERPRISE\n*  : STAR\n+K+ : KLINGON\n>!< : STARBASE\n";

                    gameOutputAppend(tutorialString);

                    trekGame.printTutorial();
                    return false;
                }
            ),

            new MenuOption("2", ") ", "TUTORIAL: SHIELDS AND TAKING DAMAGE",
                function()
                {
                    let tutorialString = "";

                    tutorialString += "\n\nSHIELDS:\nShield control will let you set the amount of the ship's energy you are committing to shields.  When shields are raised, they will absorb damage.";
                    tutorialString += "\n\nShield control (if sufficiently undamaged) will suggest a minimum shield level for the current combat situation.";
                    tutorialString += "\n\nYou can also reduce the damage you take by getting further from the enemy vessel.";
                    tutorialString += "\n\nDAMAGE:\nIf you take a hit from enemy phaser fire with no shields up, you will be destroyed.  As you take hits, various components of your ship ";
                    tutorialString += "may also degrade.  Each stardate, your repair teams will restore some small percentage of that component's integrity.  ";
                    tutorialString += "When a component's integrity gets low enough, you may see functionality impaired.  Check the damage report in the ship's computer ";
                    tutorialString += "to see both the current integrity of all your individual components as well as a list of any malfunctions.  \n\nYou can also get repairs at a starbase.";

                    gameOutputAppend(tutorialString);

                    trekGame.printTutorial();
                    return false;
                }
            ),

            new MenuOption("3", ") ", "TUTORIAL: STARBASES",
                function()
                {
                    let tutorialString = "";

                    tutorialString += "\n\STARBASES:\nDocking at a starbase will restore your energy and torpedoes to maximum and repair a random ship component to full integrity.  ";
                    tutorialString += "Each additional date docked at the starbase will fully repair an additional random component.  The starbase's shields will protect you from enemy fire so long as you are docked.";

                    tutorialString += "\n\nTo dock at a starbase, use a short range jump to navigate to a subsector adjacent to the starbase.  Then the option to dock will appear on the menu.\n\nA map of all the sectors containing starbases can be found in the ship's computer.";
                   
                    gameOutputAppend(tutorialString);

                    trekGame.printTutorial();
                    return false;
                }
            ),

            new MenuOption("4", ") ", "TUTORIAL: NAVIGATION",
                function()
                {
                    let tutorialString = "";

                    tutorialString += "\n\nNAVIGATION:\nA short range jump lets you warp to a different subsector in the current sector (eg. a different location on the current map screen). ";
                    tutorialString += "\nA long range jump lets you warp to a different sector in the galaxy (eg. change to a different map screen). ";
                    tutorialString += "\n\nA short range jump needs a clear path to the target subsector or you will exit warp.  A long range jump will take you to a random subsector of your destination sector, and will ignore any obstacles along the way.";
                    tutorialString += "\n\nBoth a short range and long range jump require more energy the further you attempt to travel.";
                    tutorialString += "\n\nIf you are in a sector with enemies, make sure you raise your shields before making a short range jump.";
            
                    gameOutputAppend(tutorialString);

                    trekGame.printTutorial();
                    return false;
                }
            ),


            new MenuOption("5", ") ", "TUTORIAL: MAPS AND SENSORS",
                function()
                {
                    let tutorialString = "";

                    tutorialString += "\n\MAPS:\n";
                    tutorialString += "Galaxy maps can be found in the ship's computer.\n\nThe starbase map shows the sectors that contain a starbase.  The locations of all starbases are known at the beginning of your mission.";
                    tutorialString += "\n\nThe klingons map shows the number of enemies in each sector based on your previous long range scans.  Starbases also do a continous long range scan and update your map.  Uncharted sectors display a question mark.";
                    tutorialString += "\n\nThe star density map shows the number of stars in each sector based on your previous long range scans.  Starbases also do a continous long range scan and update your map.  Uncharted sectors display a question mark.";
                    tutorialString += "\nThe galaxy maps in the ship computer show an E in the sector corresponding to the location of your ship.";

                    tutorialString += "\n\nSENSORS:";
                    tutorialString += "\nLong range sensors scan the 3x3 region of sectors surrounding your ship for stars and enemies, then updates the maps in the library computer.";                    
                    tutorialString += "\n\nCombat sensors will tell you the shield level of enemies in the sector, and the estimated phaser energy needed to destroy them.";
                    tutorialString += "\nYou only need to pay the energy cost of the scan once, until you leave the sector.  The ship's computer will automatically update the values as combat unfolds.\nYou can consult the scan anytime for up to date values."
            
                    gameOutputAppend(tutorialString);

                    trekGame.printTutorial();
                    return false;
                }
            ),

            new MenuOption("6", ") ", "TUTORIAL: WEAPONS",
                function()
                {
                    let tutorialString = "";

                    tutorialString += "\n\WEAPONS:\nTorpedoes will instantly destroy a single enemy vessel on impact.  ";
                    tutorialString += "They cannot pass through stars or other obstructions though, and you have a limited supply (that can be replenished at a starbase).  ";
                    tutorialString += "You should use a short range jump to navigate to a location with a clear shot.  \n\nThe targeting computer will list ";
                    tutorialString += "all the targets in the sector for you to choose from.  If the targeting computer is damaged, you may need to target the torpedoes manually.";
                    tutorialString += "\n\nPhasers ignore obstructions and target all targets in the sector at the same time.  To fire phasers you must commit some portion of your free energy to the phaser blast.\n\n";
                    tutorialString += "The more targets in the sector and the further away you are from them, the more energy you will need to commit to do the same amount of damage.";
            
                    gameOutputAppend(tutorialString);

                    trekGame.printTutorial();
                    return false;
                }
            ),

            new MenuOption("7", ") ", "BACK",
                function()
                {
                    return true;
                }
            )
        );

        this.awaitInput(tutorialMenu.toString(), 1, function(inputline){return tutorialMenu.chooseOption(inputline);});
        return false;
    }

    changeToQuadrant(qX, qY)
    {
        this.currentQuadrantScanned = false;

        this.currentQuadrant.removeEntity(this.enterprise);
        this.currentQuadrant = this.galaxyMap.lookup(qX, qY);
        this.currentQuadrant.addEntityInFreeSector(this.enterprise);

        gameOutputAppend("\nEntering galactic sector " + this.enterprise.quadrantString());
    }

    statusString()
    {
        return "<pre>" +
        "\n\n\n" + 
        "STARDATES REMAINING   " + (this.endStarDate - this.starDate) +"\n" +
        "SECTOR (X,Y)          " + (this.enterprise.quadrantX+1) +  ',' + (this.enterprise.quadrantY+1) + '\n' + 
        "SUBSECTOR (X,Y)       " + (this.enterprise.sectorX+1) +  ',' + (this.enterprise.sectorY+1) + "\n" + 
        "PHOTON TORPEDOES      " + this.enterprise.torpedoes + '\n' + 
        "SHIELD ENERGY         " + this.enterprise.shields + '\n' + 
        "FREE ENERGY           " + this.enterprise.freeEnergy + '\n' + 
        "KLINGONS REMAINING    " + Klingon.Instances + '\n' + 
        "STARBASES REMAINING   " + StarBase.Instances + '\n' +
        "</pre>";
    }

    setInputPrompt(newprompt)
    {
        document.getElementById("inputPrompt").innerHTML = newprompt;

    }

    shieldHandler(inputline)
    {
        let parsedVal = parseInt(inputline);

        if (isNaN(parsedVal) || parsedVal < 0)
        {
            gameOutputAppend("Invalid value!");
            return false;
        }
        if (parsedVal > (this.enterprise.shields + this.enterprise.freeEnergy))
        {
            gameOutputAppend("We don't have enough energy for that, captain!");
            return false;
        }
        
        //gameOutputAppend(""+parsedVal);

        this.enterprise.setShieldLevel(parsedVal);

        this.combatStep();

        return true;
    }


    // finalHandler has prototype (game, x, y)
    getSubsectorMenu(finalHandler)
    {
        let promptstringX = "Enter destination subsector X coordinate.  Enter a value between 1 and " + quadrantWidthSectors;
        let promptstringY = "Enter destination subsector Y coordinate.  Enter a value between 1 and " + quadrantHeightSectors;

        let trekgame = this;

        let yhandler = function(inputline, subsectorX)
        {
            let subsectorY = parseInt(inputline) - 1;

            if ((subsectorY == null) || isNaN(subsectorY) || subsectorY < 0 || subsectorY >= quadrantHeightSectors)
            {
                gameOutputAppend("Invalid value!");
                return false;
            }

            return finalHandler(game, subsectorX, subsectorY);
        };

        let xhandler = function(inputline)
        {
            let subsectorX = parseInt(inputline) - 1;

            if ((subsectorX == null) || isNaN(subsectorX) || subsectorX < 0 || subsectorX >= quadrantWidthSectors)
            {
                gameOutputAppend("Invalid value!");
                return false;
            }

            this.awaitInput
            (
                promptstringY,
                2, 
                function(inputline)
                {
                    return yhandler(inputline, subsectorX)
                }
            );
            
            return false;
        }

        this.awaitInput(
            promptstringX,
            2,
            xhandler
        );

    }

    navigationHandlerLongRangeX(inputline)
    {
        console.log("nav");
        let quadrantX = parseInt(inputline) - 1;

        if ((quadrantX == null) || isNaN(quadrantX) || quadrantX < 0 || quadrantX >= mapWidthQuadrants)
        {
            gameOutputAppend("Invalid value!");
            return false;
        }

        this.awaitInput(
            "Enter destination sector Y coordinate.  Enter a value between 1 and " + mapHeightQuadrants,
            2, 
            
            function(inputline)
            {
                return this.navigationHandlerLongRangeY(inputline, quadrantX);
            }
        );
        
        return false;
    }

    navigationHandlerLongRangeY(inputline, quadrantX)
    {
        let quadrantY = parseInt(inputline) - 1;

        if ((quadrantY == null) || isNaN(quadrantY) || quadrantY < 0 || quadrantY >= mapHeightQuadrants)
        {
            gameOutputAppend("Invalid value!");
            return false;
        }

        let xd = quadrantX - this.enterprise.quadrantX;
        let yd = quadrantY - this.enterprise.quadrantY;
        let travelDistance = Math.sqrt(xd*xd + yd*yd);  // assumes single stardate.  so distance and speed have the same scalar value.

        let maxSpeed = this.enterprise.components.WarpEngines.maxSpeed();

        if (!this.enterprise.components.WarpEngines.fullyFunctional())
        {
            xd /= travelDistance;
            yd /= travelDistance;

            xd *= maxSpeed;
            yd *= maxSpeed;
            
            travelDistance = Math.sqrt(xd*xd + yd*yd);

            quadrantX = Math.floor(this.enterprise.quadrantX + xd);
            quadrantY = Math.floor(this.enterprise.quadrantY + yd);

            gameOutputAppend("Unable to make it to the destination warp target in a single jump due to damage.  New destination is Sector " + (quadrantX+1) + ", " + (quadrantY+1));
        }

        let jumpEnergyRequired = Math.floor(Enterprise.EnergyCostPerQuadrant * travelDistance);

        if (this.enterprise.freeEnergy < jumpEnergyRequired)
        {
            gameOutputAppend("Insufficient energy for long range jump, captain.  Jump requires " + jumpEnergyRequired + " free energy.");
            return true;
        }

        let trekgame = this;
        let confirmMenu = new Menu();
        confirmMenu.options.push
        (
            new MenuOption
            (
                "1", 
                ") ", 
                "CONFIRM JUMP TO SECTOR " + (quadrantX+1) + ", " + (quadrantY+1) + ".\nTRIP TAKES 1 STARDATE, " + jumpEnergyRequired + " ENERGY\n",
                function()
                {
                    trekgame.enterprise.freeEnergy -= jumpEnergyRequired;
                    trekgame.changeToQuadrant(quadrantX, quadrantY);
                    trekgame.advanceStardateNoCombat(1.0); // don't get blown up as soon as we enter a new Sector!
                    return true;
                }
            ),

            new MenuOption
            (
                "2",
                ") ",
                "CANCEL",
                function()
                {
                    return true;
                }
            )
        );

        this.awaitInput(confirmMenu.toString(), 1, function(inputline){return confirmMenu.chooseOption(inputline);});
    }

    shortRangeNavigationHandler(trekgame, subsectorX, subsectorY)
    {
        let sectorsToTravel = trekgame.enterprise.distanceToSectorLoc(subsectorX, subsectorY);

        let confirmFunc = function()
        {
            if (trekgame.enterprise.warp(subsectorX, subsectorY, sectorsToTravel, trekgame))
            {
                gameOutputAppend("\nComing out of warp in sector " + trekgame.enterprise.quadrantString());
                trekgame.advanceStardate(1.0);
            }

            return true;
        }

        let jumpEnergyRequired = Math.round(trekgame.enterprise.warpEnergyCost(sectorsToTravel));

        let confirmMenu = new Menu();
        confirmMenu.options.push
        (
            new MenuOption
            (
                "1", 
                ") ", 
                "CONFIRM JUMP TO SUBSECTOR " + (subsectorX+1) + ", " + (subsectorY+1) + ".\nTRIP TAKES 1 STARDATE, " + jumpEnergyRequired + " ENERGY\n",
                confirmFunc
            ),

            new MenuOption
            (
                "2",
                ") ",
                "CANCEL",
                function()
                {
                    return true;
                }
            )
        )
        
        trekgame.awaitInput(confirmMenu.toString(), 1, function(inputline){return confirmMenu.chooseOption(inputline);});
        return false;
    }

    scanEnemyShips()
    {
        if (this.enterprise.freeEnergy < Enterprise.EnemyScanCost)
        {
            gameOutputAppend("\nNot enough energy to scan the enemy ships, captain!");
            return;
        }

        let enemylist = this.currentQuadrant.getEntitiesOfType(Klingon);

        if (!enemylist.length)
        {
            gameOutputAppend("\nNo enemies in this sector to scan, captain!");
            return;
        }

        this.enterprise.freeEnergy -= Enterprise.EnemyScanCost;
        this.currentQuadrantScanned = true;

        gameOutputAppend("\nENEMY SHIP SCANNER REPORTS");

        let e_max_of_min = 0;
        let e_max_of_max = 0;

        let allEnemiesVisible = true;

        for (var x in enemylist)
        {
            let k = enemylist[x];

            // invert the enterprise phaser equations to get the estimate 
            ///\todo make this a subfunction of Enterprise...

            let kshields = k.shields;
            let dist_to_k = this.enterprise.distanceToObject(k);

            let minRandom = 2.0;
            let maxRandom = 3.0;

            let e_required_max = dist_to_k * kshields / minRandom;
            let e_required_min = dist_to_k * kshields / maxRandom;

            e_max_of_min = Math.max(e_required_min, e_max_of_min);
            e_max_of_max = Math.max(e_required_max, e_max_of_max);
            
            let entityVisible = this.enterprise.canSeeEntity(k);
            if (!entityVisible)
            {
                allEnemiesVisible = false;
                gameOutputAppend("\n---SENSOR CORRUPTION DETECTED!---");
                gameOutputAppend("Enemy in subsector : ???");
                gameOutputAppend("Enemy shield level : ????");
                gameOutputAppend("Phaser energy to destroy : ??????");
            }
            else
            {
                gameOutputAppend("\nEnemy in subsector (" + k.sectorString() + ")");
                gameOutputAppend("Enemy shield level : " + kshields);
                gameOutputAppend("Phaser energy to destroy : " + Math.round(e_required_min) + "-" + Math.round(e_required_max));
            }
        }

        gameOutputAppend("\nTotal enemies : " + enemylist.length);
        
        if (allEnemiesVisible)
        {
            gameOutputAppend("Total energy to destroy : " + Math.round(enemylist.length * e_max_of_min) + "-" + Math.round(enemylist.length * e_max_of_max));
        }
        else
        {
            gameOutputAppend("Total energy to destroy : ?????");
        }
        gameOutputAppend("\n");
    }

    longRangeScan()
    {

        if (!this.enterprise.components.LongRangeSensors.functional())
        {
            gameOutputAppend("\nLong range scan unavailable due to damage.");
            return;
        }

        gameOutputAppend("\nLong Range Scan completed.");
        gameOutputAppend("Adjacent sectors have been scanned.  The ship's computer has been updated with the following information:\n");
        gameOutputAppend(this.enterprise.lrsString(this.galaxyMap));

        var sh = this.enterprise.sensorHistory;
        sh.updateSensorHistoryForEntityTypes
        (
            [Star, Klingon], 
            this.galaxyMap, 
            this.enterprise.quadrantX-1, 
            this.enterprise.quadrantY-1, 
            this.enterprise.quadrantX+1, 
            this.enterprise.quadrantY+1
        );

        this.advanceStardate(1.0);
    }

    manualTorpedoHandler()
    {
        let tfunc = function(trekgame, x, y){
            let gobj = new GameObject();
            gobj.sectorX = x;
            gobj.sectorY = y;
            trekgame.torpedoHandler(gobj)
            return true;
        };

        this.getSubsectorMenu(tfunc);
    }

    torpedoHandler(target)
    {
        this.enterprise.fireTorpedo(this, target);

        this.combatStep();

        return true;
    }

    phaserHandler(inputline)
    {
        let energy = parseInt(inputline);

        if ((energy == null) || isNaN(energy) || energy < 0)
        {
            gameOutputAppend("Invalid value!");
            return false;
        }

        if (energy > this.enterprise.freeEnergy)
        {
            gameOutputAppend("Not enough energy, captain!");
            return false;
        }

        if (energy == 0)
        {
            return true;
        }

        if (this.enterprise.firePhasers(energy, this))
        {
            this.combatStep();
        }

        return true;
    }

    combatStep()
    {
        this.currentQuadrant.klingonsFire(this.enterprise, this);
        this.enterprise.components.ShortRangeSensors.generateCorruptGrid();
    }

    updateStatus()
    {
        document.getElementById("status").innerHTML = this.statusString();
    }

    awaitInput(inputPrompt, charactersToRead=3, inputHandler=null)
    {
        document.getElementById("inputPrompt").style.display="Block";
        document.getElementById("gameInput").style.display="Block";
        document.getElementById("inputButton").style.display ="Block";

        this.inputHandler = inputHandler;
        document.getElementById("gameInput").maxLength = charactersToRead;
        this.setInputPrompt(inputPrompt);
    }

    disableInput()
    {
        document.getElementById("inputPrompt").style.display="None";
        document.getElementById("gameInput").style.display="None";
        document.getElementById("inputButton").style.display ="None";
    }

    handleInput(inputStr)
    {
        if (this.inputHandler)
        {
            if (this.inputHandler(inputStr))
            {
                this.awaitInput(this.mainMenu.toString(), 3, null);
            }
        }
        else
        {
            this.mainMenu.chooseOption(inputStr);
        }
    }

    gameInput(inputStr)
    {
        //console.log(">"+inputStr+"\n");
        //gameOutputAppend(inputStr);

        this.handleInput(inputStr);

        this.updateGame();
        autosave(this);
    }

    updateDisplay()
    {
        this.updateStatus();
        updateMap(this.updateMapScreen());
        updateMapHeader("SECTOR : " + this.enterprise.quadrantString());
        updateMapFooter(this.updateStatusFlags());
    }

    checkStarbaseDock()
    {
        if (this.enterprise.dockStarbase)
        {
            console.log("already docked.");
            return;
        }

        this.mainMenu.dockOption.enabled = false;

        let starbases = this.currentQuadrant.getEntitiesOfType(StarBase);

        for (var x in starbases)
        {
            var sb = starbases[x];

            if (this.enterprise.isAdjacentTo(sb))
            {
                console.log("adjacent");
                this.mainMenu.dockOption.enabled = true;
            }
            else
            {
                console.log("not adjacent");
            }
        }

        if (!this.inputHandler)
        {
            this.awaitInput(this.mainMenu.toString(), 3, null);
        }
    }

    updateGame()
    {
        this.updateDisplay();
        this.starbasesScan();
        this.enterpriseShortRangeScan();
        this.checkStarbaseDock();

        this.checkEndConditions();
    }

    enterpriseShortRangeScan()
    {
        this.enterprise.sensorHistory.updateSensorHistoryForEntityTypes
            (
                [Star, Klingon], 
                this.galaxyMap, 
                this.enterprise.quadrantX, 
                this.enterprise.quadrantY, 
                this.enterprise.quadrantX, 
                this.enterprise.quadrantY
            );
    }

    endGame()
    {
        this.gameOver = true;
        autosave(null);
        gameOutputAppend("\nThanks for playing!  Refresh the page to play again.");
        this.disableInput();
    }

    advanceStardate(adv)
    {
        this.combatStep();
        this.advanceStardateNoCombat(adv);
    }

    advanceStardateNoCombat(adv)
    {
        this.starDate += adv;
        this.enterprise.autoRepairComponents();

        let stardatesRemaining = (this.endStarDate - this.starDate);

        if (stardatesRemaining == 10)
        {
            gameOutputAppend("\nYou have 10 stardates remaining to complete your mission!");
        }
        else if (stardatesRemaining == 5)
        {
            gameOutputAppend("\nWARNING : 5 STARDATES REMAIN.");
        }
        else if (stardatesRemaining == 1)
        {
            gameOutputAppend("" + stardatesRemaining + " STARDATE LEFT!");
        }
        else if (stardatesRemaining <= 3)
        {
            gameOutputAppend("" + stardatesRemaining + " STARDATES LEFT!");
        }
    }

    checkEndConditions()
    {
        if (this.gameOver) return;

        if (this.starDate >= this.endStarDate)
        {
            gameOutputAppend("\n\n============================GAME OVER============================\n");
            gameOutputAppend("You were unable to complete your mission in time.");
            gameOutputAppend("The Klingons were able to execute their plan to destroy the Federation starbases!");
            gameOutputAppend("You'll be demoted for sure!");

            gameOutputAppend("\nFinal Score : " + this.generateScore(false));

            this.endGame();
        }
        else if (this.enterprise.isStranded())
        {
            gameOutputAppend("\n\n============================GAME OVER============================\n");
            gameOutputAppend("You have insufficient energy to power the warp engines!");
            gameOutputAppend("You are stranded, causing you to ultimately fail your mission.");

            gameOutputAppend("\nFinal Score : " + this.generateScore(false));
            
            this.endGame();
        }
        else if (this.enterprise.isDestroyed())
        {
            gameOutputAppend("\n\n============================GAME OVER============================\n");
            gameOutputAppend("Your vessel has taken too much damage and has been destroyed.");
            gameOutputAppend("Your mission is failed.");

            gameOutputAppend("\nFinal Score : " + this.generateScore(false));

            this.endGame();
        }
        else if (!StarBase.Instances)
        {
            gameOutputAppend("\n\n============================\GAME OVER============================\n");
            gameOutputAppend("All the Federation starbases have been destroyed!");
            gameOutputAppend("You've failed in your mission.  The Federation is doomed.");

            gameOutputAppend("\nFinal Score : " + this.generateScore(false));

            this.endGame();
        }
        else if (!Klingon.Instances)
        {
            gameOutputAppend("\n\n============================YOU WIN!!============================\n");
            gameOutputAppend("You've managed to destroy all the enemy vessels, preventing the enemy from executing their plan!");
            gameOutputAppend("You're sure to get a promotion!");
            gameOutputAppend("Congratulations on your victory!");

            gameOutputAppend("\nFinal Score : " + this.generateScore(true));
            
            this.endGame();
        }
    }
    
    createMenus()
    {
        this.mainMenu = new MainMenu(this);
        this.computerMenu = new ShipComputerMenu(this);
    }


    updateStatusFlags()
    {
        let flags = [];
        
        if (this.enterprise.dockStarbase)
        {
            flags.push("DOCKED");
        }

        if (this.currentQuadrant.countEntitiesOfType(Klingon))
        {
            flags.push("RED ALERT");

            if (this.enterprise.isShieldLevelCritical(this.currentQuadrant.getEntitiesOfType(Klingon)))
            {
                flags.push("SHIELDS CRITICAL");
            }
        }
        else
        {
            flags.push("SECTOR CLEAR");
        }

        return flags.join(" | ");
    }

    updateMapScreen()
    {
        let quad = this.currentQuadrant;

        let borderStringPost = "   " + mapFooter(quadrantWidthSectors);
        let borderStringPre = "   " + mapHeader(quadrantWidthSectors) + '\n';

        let quadrantStringGrid = new Grid(quad.width, quad.height, function(){return " ".padStart(sectorDisplayWidthChars, ' ')})

        var gameObjectIndex;
        for (gameObjectIndex in quad.quadrantEntities)
        {
            let gameObject = quad.quadrantEntities[gameObjectIndex];
            var objStr;
        
            objStr = gameObject.toString().padStart(sectorDisplayWidthChars, ' ');

            quadrantStringGrid.setValue(gameObject.sectorX, gameObject.sectorY, objStr);
        }

        if (!this.enterprise.components.ShortRangeSensors.fullyFunctional())
        {
            // randomly go through and corrupt the short range scan based on the health of the ship components
            for (var x in quadrantStringGrid.contents)
            {   
                if (this.enterprise.components.ShortRangeSensors.isSectorCorrupt1D(x))
                {
                    quadrantStringGrid.setValue1D(x, '?'.padStart(sectorDisplayWidthChars, ' '));
                }
            }
        }

        let mapString = quadrantStringGrid.toString();

        return "<pre>" + borderStringPre + mapString + borderStringPost + "</pre>";

    }
}

TrekGame.EntityTypes = [Star, StarBase, Klingon];
TrekGame.BaseMissionTime = 25;
TrekGame.MissionTimeSpread = 10;

function createEntityMap(entityList)
{
    var map = new Map();
    var x;
    for (x in entityList)
    {
        let etype = entityList[x];
        map.set(etype.name, etype);
    }
    return map;
}

const EntityMap = createEntityMap(TrekGame.EntityTypes);

console.log("Hope you enjoy the game!");