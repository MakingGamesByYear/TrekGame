// TrekGame.js
// Generated on Mon Jul 29 17:53:46 EDT 2019
// Making Games By Year, Episode 1
// Script generated megafile from individual .js files
// Do not edit this file, edit individual scripts in the source dir and re-run compile.sh


// ------- globals.js ------- 
const mapWidthQuadrants = 8;
const mapHeightQuadrants = 6;
const quadrantWidthSectors = 10;
const quadrantHeightSectors = 10;
const sectorDisplayWidthChars = 4;
const minKlingonsGame = 8;


// ------- util.js ------- 
function checkArgumentsDefinedAndHaveValue(args)
{
    var x;
    for (x in args)
    {
        arg = args[x];
        console.assert(!(typeof arg == "undefined" || arg == null));
    }
}

function padStringToLength(str, len, padWithChar = ' ')
{
    console.assert(str.length <= len);
    console.assert(padWithChar.length == 1);

    checkArgumentsDefinedAndHaveValue(arguments);

    let padLength = len - str.length;
    let pad1 = Math.floor(padLength / 2);
    let pad2 = padLength - pad1;
    let padLeft = Math.max(pad1,pad2);

    let leftPadStr = str.padStart(padLeft + str.length, padWithChar);

    return leftPadStr.padEnd(len, padWithChar);
}

function randomInt(min, max)
{
    checkArgumentsDefinedAndHaveValue(arguments);
    return Math.round(Math.random() * (max-min) + min);
}

function randomFloat(min, max)
{
    checkArgumentsDefinedAndHaveValue(arguments);
    return (Math.random() * (max-min) + min);
}

function gameOutputScrollToBottom()
{
    let textarea = document.getElementById("gameOutputBox");
    textarea.scrollTop = textarea.scrollHeight;
}

function gameOutputAppend(str)
{
    let textarea = document.getElementById("gameOutputBox")
    textarea.value += str + '\n';
    textarea.scrollTop = textarea.scrollHeight;
}

function updateMap(mapString = game.currentQuadrant.toString())
{
    document.getElementById("map").innerHTML = mapString;
}

function updateMapHeader(str)
{
    document.getElementById("mapHeaderQuadrant").innerHTML = "<pre>"+str+"</pre>";
}

function updateMapFooter(str)
{
    document.getElementById("statusflags").innerHTML = "<pre>"+str+"</pre>";
}

function autosave(game)
{
    //console.log("autosave func");
    //console.log(JSON.stringify(game));

    if (game && !game.gameOver)
    {
        localStorage.setItem("autosave", JSON.stringify(game));

        let textarea = document.getElementById("gameOutputBox")
        localStorage.setItem("outputText", textarea.value);
    }
    else
    {
        localStorage.setItem("autosave", null);
        localStorage.setItem("outputText", null);
    }
}

function makeCDF(instanceProbabilities)
{
    var rval = [];
    let totalSum = 0.0;

    for (var x in instanceProbabilities)
    {
        totalSum += instanceProbabilities[x];
        rval.push(totalSum);
    }

    for (var x in rval)
    {
        rval[x] /= totalSum;
    }

    // last value should always be exactly 1
    rval[rval.length-1] = 1.0;

    return rval;
}

// generates a random value, between 0 and valueProbabilities.length-1, where each possible value's chance of
// being generated is listed in the corresponding array entry
function randomWithProbabilities(valueProbabilities)
{
    let randomVal = randomFloat(0.0, 1.0);
    let cdf = makeCDF(valueProbabilities);

    //console.log("" + cdf);
    var x;
    for (x in cdf)
    {
        if (randomVal < cdf[x])
        {
            return x;
        }
    }
    return cdf.length-1;
}

function mapFooter(length)
{
    let rval = "";

    for (var x = 0; x < length; x++)
    {
        rval += "=";
        rval += padStringToLength(""+(x+1), 3, '-');
    }

    return rval;
}

function mapHeader(length)
{
    let rval = "";

    for (var x = 0; x < length; x++)
    {
        rval += "=---";
    }

    return rval;
}

// ------- Grid.js ------- 
class Grid
{
    constructor(gridX, gridY, gridItemConstructor = function(){return null;})
    {
        checkArgumentsDefinedAndHaveValue(arguments);

        this.contents = new Array()

        this.width = gridX;
        this.height = gridY;
        this.size = gridX * gridY;

        for (let y = 0; y < this.height; y++)
        {
            for (let x = 0; x < this.width; x++)
            {
                this.contents.push(gridItemConstructor(x, y));
            }
        }
    }

    lookup(x,y)
    {
        checkArgumentsDefinedAndHaveValue(arguments);

        if (x < 0 || x >= this.width || y < 0 || y >= this.height)
        {
            return null;
        }

        return this.contents [y * this.width + x];
    }

    // 1D array based lookup
    lookup1D(x)
    {
        checkArgumentsDefinedAndHaveValue(arguments);
        return this.contents[x];
    }

    setValue(x,y,val)
    {
        checkArgumentsDefinedAndHaveValue(arguments);
        this.contents [y * this.width + x] = val;
    }

    setValue1D(x, val)
    {
        this.contents[x] = val;
    }

    getEmptySquare()
    {
        let startIndex = randomInt(0, this.contents.length-1);
        let emptyIndex = null;

        for (let i = 0; i < this.contents.length; i++)
        {
            let lookup = ( startIndex + i ) % this.contents.length;
            if (!this.contents.lookup)
            {
                emptyIndex = i;
                break;
            }
        }

        if (emptyIndex)
        {
            let rx = emptyIndex % this.width;
            let ry = emptyIndex / this.height;

            return {x : rx, y:ry};
        }
        
        return null;
    }

    toStringHyperlink()
    {
        let rval = "";
        for ( let y = 0; y < this.height; y++)
        {
            rval += padStringToLength(""+(y+1), 2) + '|';
            for (let x = 0; x < this.width; x++)
            {
                let lookupVal = this.lookup(x,y).toString();
                if (lookupVal == padStringToLength(' ', lookupVal.length))
                {
                    lookupVal = padStringToLength('.', lookupVal.length);
                }

                let catstr = "<a href=\"javascript:clickGridHandler("+x+","+y+")\" style=\"color: rgb(0,255,0); text-decoration: none;\">" + lookupVal + "</a>";
                rval += catstr;
            }
            rval += '|';
            rval += '\n';
        }
        return rval;
    }

    toStringTyping()
    {
        let rval = "";
        for ( let y = 0; y < this.height; y++)
        {
            rval += padStringToLength(""+(y+1), 2) + '|';
            for (let x = 0; x < this.width; x++)
            {
                let catstr = this.lookup(x,y).toString();
                rval += catstr;
            }
            rval += '|';
            rval += '\n';
        }
        return rval;
    }

    toString()
    {
        return Grid.TypingFree ? this.toStringHyperlink() : this.toStringTyping();
    }
}

Grid.TypingFree = false;

// ------- GameObject.js ------- 
class GameObject
{
    constructor(className)
    {
        this.sectorX = 0;
        this.sectorY = 0;
        this.quadrantX = 0;
        this.quadrantY = 0;
        this.entityType = this.constructor.name;

        if (className)
        {
            if (!className.Instances)
            {
                className.Instances = 0;
            }

            className.Instances++;
        }
    }

    isAdjacentTo(obj2)
    {
        let sameQuadrant = (this.quadrantX == obj2.quadrantX) && (this.quadrantY == obj2.quadrantY);
        let xSectorDiff = Math.abs(this.sectorX - obj2.sectorX);
        let ySectorDiff = Math.abs(this.sectorY - obj2.sectorY);

        console.log("quad x y " + sameQuadrant + " " + xSectorDiff + " " + ySectorDiff);

        return sameQuadrant && (xSectorDiff <= 1) && (ySectorDiff <= 1);
    }

    distanceToObject(obj2)
    {
        return this.distanceToSectorLoc(obj2.sectorX, obj2.sectorY);
    }

    distanceToSectorLoc(sectorX, sectorY)
    {
        let xdiff = this.sectorX - sectorX;
        let ydiff = this.sectorY - sectorY;
        return Math.sqrt(xdiff*xdiff + ydiff*ydiff);
    }

    setLocationSector(sectorXY)
    {
        this.sectorX = sectorXY.x;
        this.sectorY = sectorXY.y;
    }

    onTorpedoHit(game)
    {
        console.log("Torpedo hit (base class)");
    }

    // randomly generate the number of GameObject instances to put in a new quadrant
    static randomCountForQuadrant(quadrantFreeSpaces, instancesInQuadrant)
    {
        var rval = 0;

        let instanceProbabilities = this.quadrantInstanceProbabilities();
        if (instanceProbabilities == null)
        {
            //console.log("Using uniform probability path");
            rval = randomInt(0, this.maxInstancesQuadrant());
        }
        else
        {
            //console.log("Using CDF Probability Path");
            console.assert(instanceProbabilities.length == (1+this.maxInstancesQuadrant()));
            
            rval = randomWithProbabilities(instanceProbabilities);
        }

        rval = Math.min(rval, quadrantFreeSpaces);

        // createEntities occurs after we place our minimum number of entities around the map.
        // so if we've already created some entities in this quadrant just deduct them from the ones
        // the rng says we need to create.

        if (!this.Instances)
        {
            this.Instances = 0;
        }

        rval = Math.min(rval, this.maxInstancesGame() - this.Instances);

        console.assert(this.Instances <= this.maxInstancesGame());

        rval = Math.max(rval - instancesInQuadrant, 0);

        return rval;
    }

    sectorString()
    {
        return "" + (this.sectorX+1) + ", " + (this.sectorY+1);
    }

    quadrantString()
    {
        return "" + (this.quadrantX+1) + ", " + (this.quadrantY+1);
    }

    sectorStringFractional()
    {
        let sectorXFractional = (this.quadrantX+1) + (this.sectorX / quadrantWidthSectors);
        let sectorYFractional = (this.quadrantY+1) + (this.sectorY / quadrantHeightSectors);
        return "("+sectorXFractional+","+sectorYFractional+")";
    }

    static minInstancesGame()
    {
        return 0;
    }

    static maxInstancesQuadrant()
    {
        return 8;
    }

    static maxInstancesGame()
    {
        return this.maxInstancesQuadrant() * mapWidthQuadrants * mapHeightQuadrants;
    }

    // returns array containing the probability of each instance count appearing in a quadrant at map generation
    // eg. [.1, .2, .15, .55]
    // means that there's a 10% chance of no instances of the object in a given quadrant
    // there's a 20% chance of 1 instance
    // a 15% chance of 2 instances
    // a 55% chance of 3 instances
    // The base class GameObject method returns null, if we want to just generate uniform probabilities (default)
    // eg. each number between min and max has an equal likelihood.
    // So in the above example, there'd be a 25% chance of either no instance, 1 instance, 2 instances, or 3 instances
    static quadrantInstanceProbabilities()
    {
        return null;
    }
}

// ------- StarBase.js ------- 
class StarBase extends GameObject
{
    constructor()
    {
        super(StarBase);
        StarBase.starbaseList.push(this);
    }

    onTorpedoHit(game)
    {
        console.log("hit a starbase");

        game.currentQuadrant.removeEntity(this);
        StarBase.Instances--;

        let removeSB = this;
        StarBase.starbaseList = StarBase.starbaseList.filter(function(item){return item != removeSB});

        if (game.enterprise.dockStarbase == removeSB)
        {
            game.enterprise.undock(removeSB);
        }

        gameOutputAppend("\nReport from sector " + this.sectorString());
        if (game.primeUniverse)
        {
            gameOutputAppend("The torpedo strikes and destroys the friendly starbase! I bet you'll be court martialled for that one!");
        }
        else
        {
            gameOutputAppend("The torpedo strikes and destroys the Imperial starbase! Starfleet orders your second in command to throw you in the agonizer booth, costing you a Stardate.");
            game.advanceStardate(1.0);
        }
    }

    toString()
    {
        return ">!<";
    }

    static maxInstancesQuadrant()
    {
        return 1;
    }

    static minInstancesGame()
    {
        return 1;
    }

    static quadrantInstanceProbabilities()
    {
        // 5% chance of a starbase in any given quadrant
        return [.95, .05];
    }
}

StarBase.starbaseList = [];

// ------- Planet.js ------- 
// planet lets you bombard with torpedoes when adjacent, in order to cause enemy ships to warp in
class Planet extends GameObject
{
    constructor()
    {
        console.log("Planet created!")
        super(Planet);
        this.bombarded = false;
    }

    onTorpedoHit(game)
    {
        gameOutputAppend("\nReport from sector " + this.sectorString());
        gameOutputAppend("The torpedo burns up in the planet's atmosphere.");
    }

    bombard()
    {
        this.bombarded = true;
    }

    toString()
    {
        return "O";
    }

    static maxInstancesGame()
    {
        return Planet.MaxInstances;
    }

    static maxInstancesQuadrant()
    {
        return 1;
    }

    static minInstancesGame()
    {
        return Planet.MinInstances;
    }

    static quadrantInstanceProbabilities()
    {
        // 5% chance of a planet in any given quadrant
        return [.95, .05];
    }
}

Planet.MaxInstances = 3;
Planet.MinInstances = 1;



// ------- Klingon.js ------- 
class Klingon extends GameObject
{
    constructor()
    {
        super(Klingon);
        this.shields = randomInt(100, 300);
    }

    onTorpedoHit(game)
    {
        console.log("hit a klingon");
        gameOutputAppend("\nReport from sector " + this.sectorString());
        
        game.destroyKlingon(this);
    }

    onPhaserHit(energy, game)
    {
        console.log("Klingon::onPhaserHit");
        let shieldDeflectionLevel = Klingon.shieldDeflectionPercent * this.shields;

        gameOutputAppend("\nReport from sector " + this.sectorString());

        if (energy <= shieldDeflectionLevel)
        {
            gameOutputAppend("Phaser hit did no damage!");
        }
        else
        {
            let descStr = game.primeUniverse ? "klingon fighter" : " enemy ship";
            gameOutputAppend("Phaser hit the " + descStr + " for " + energy + " damage.");

            this.shields -= energy;

            if (this.shields <= 0)
            {
                game.destroyKlingon(this);
            }
            else
            {
                if (game.currentQuadrantScanned)
                {
                    if (game.enterprise.canSeeEntity(this))
                    {
                       gameOutputAppend("" + this.shields + " units remain.");
                    }
                    else
                    {
                        gameOutputAppend("Sensor damage prevents reading the enemy's shields!");
                    }
                }
            }
        }
    }

    phaserDamageBase(dist)
    {
        let energyToFire = this.shields;
        return Math.round(energyToFire / dist);
    }

    firePhasers(target, game)
    {
        let dist = this.distanceToObject(target);
        let phaserDamage = this.phaserDamageBase(dist) * randomInt(Klingon.MinPhaserMultiplier, Klingon.MaxPhaserMultiplier);

        let sstr = game.enterprise.canSeeEntity(this) ? this.sectorString() : " ???? ";
        gameOutputAppend("\nHit from sector " + sstr + " for " + phaserDamage + " units");
        target.onPhaserHit(phaserDamage, game);
    }

    minPhaserDamage()
    {
        return Klingon.MinPhaserMultiplier * this.phaserDamageBase(1);
    }
    
    maxPhaserDamage()
    {
        return Klingon.MaxPhaserMultiplier * this.phaserDamageBase(1);
    }

    toString()
    {
        return Klingon.stringRepresentation;
    }
    
    static maxInstancesQuadrant()
    {
        return 4;
    }

    static quadrantInstanceProbabilities()
    {
        return [.9,  
                .025,
                .025,
                .0125,
                .00625
        ];
    }

    static maxInstancesGame()
    {
        return 18;
    }

    static minInstancesGame()
    {
        return minKlingonsGame;
    }
}

Klingon.shieldDeflectionPercent = .15;
Klingon.InstancesDestroyed = 0;
Klingon.MaxPhaserMultiplier = 3;
Klingon.MinPhaserMultiplier = 2;

Klingon.stringRepresentation = "+K+";

// ------- Star.js ------- 
class Star extends GameObject
{
    constructor()
    {
        super(Star);
    }

    onTorpedoHit(game)
    {
        console.log("hit a star");
        gameOutputAppend("\nReport from sector " + this.sectorString(this.sectorX, this.sectorY));
        gameOutputAppend("The star absorbs the torpedo without a trace.");
    }

    toString()
    {
        return "*";
    }

    static maxInstancesQuadrant()
    {
        return 9;//12;
    }
}

// ------- ShipComponents.js ------- 
class ShipComponent
{
    constructor (componentName, damProb)
    {
        this.componentHealth = 1.0; //percent
        this.componentName = componentName;
        this.componentDamageProbability = damProb;
    }

    damageReport()
    {
    }

    passthroughDamage(enterprise, damage)
    {
        this.componentHealth -= Math.min(damage, this.componentHealth);
    }
}

// cap speed.
class WarpEnginesComponent extends ShipComponent
{
    constructor()
    {
        super("Warp Engines", .0625);
    }

    fullyFunctional()
    {
        return this.componentHealth >= WarpEnginesComponent.FullyFunctionalHealth;
    }

    damageReport()
    {
        gameOutputAppend("At its current level of repair, the warp engines can achieve a speed of " + Math.round(this.maxSpeed()) + " sectors per stardate");
    }

    maxSpeed()
    {
        let t = Math.min(1.0, this.componentHealth / WarpEnginesComponent.FullyFunctionalHealth);
        return (1.0 - t) * WarpEnginesComponent.MinSpeed + t * WarpEnginesComponent.MaxSpeed;
    }
}

WarpEnginesComponent.FullyFunctionalHealth = .8;

// min sectors to travel in a single stardate jump.  Cover at least sqrt(2) so we can go one sector in any direction even diagonal
WarpEnginesComponent.MinSpeed = 1.5;

// max sectors to travel in a single stardate jump.  sqrt 2 for diagonal (pythagorean)
WarpEnginesComponent.MaxSpeed = Math.sqrt(2.0) * Math.max(mapWidthQuadrants, mapHeightQuadrants);


class ShortRangeSensorsComponent extends ShipComponent
{
    constructor()
    {
        super("Short Range Sensors", .0625);
        this.generateCorruptGrid();
    }

    fullyFunctional()
    {
        return this.componentHealth > ShortRangeSensorsComponent.FullyFunctionalHealth;
    }

    chanceCorrupt()
    {
        // goes from 0 when the component is at the maximum health in range, to 1 when the component is at 0%
        let hnorm = (ShortRangeSensorsComponent.FullyFunctionalHealth - this.componentHealth) / ShortRangeSensorsComponent.FullyFunctionalHealth;

        // lerp
        let chanceCorrupt = (1.0 - hnorm) * ShortRangeSensorsComponent.MinChanceCorrupt + hnorm * ShortRangeSensorsComponent.MaxChanceCorrupt;

        return chanceCorrupt;
    }

    damageReport()
    {
        if (!this.fullyFunctional())
        {
            gameOutputAppend("Short range sensors are damaged.  Map display may be corrupted.");
        }
    }

    generateCorruptGrid()
    {
        this.corruptGrid = new Grid(quadrantWidthSectors, quadrantHeightSectors);

        let corruptChance = this.chanceCorrupt();

        for (var x in this.corruptGrid.contents)
        {
            this.corruptGrid.setValue1D(x, Math.random() < corruptChance);
        }
    }

    isSectorCorrupt1D(x)
    {
        return this.corruptGrid.lookup1D(x);
    }

    isSectorCorrupt(x, y)
    {
        return this.corruptGrid.lookup(x,y);
    }
}

ShortRangeSensorsComponent.FullyFunctionalHealth = .7;   // short range scan fully functional above this health
ShortRangeSensorsComponent.MinChanceCorrupt = .1;        // For a particular sector on the map, minimum chance it'll be corrupt when integrity is high
ShortRangeSensorsComponent.MaxChanceCorrupt = .75;       // For a particular sector on the map, maximum chance it'll be corrupt when integrity is low


class LongRangeSensorsComponent extends ShipComponent
{
    constructor()
    {
        super ("Long Range Sensors", .25);
    }

    functional()
    {
        return this.componentHealth >= LongRangeSensorsComponent.FullyFunctionalHealth;
    }

    damageReport()
    {
        if (!this.functional())
        {
            gameOutputAppend("Long range sensors disabled.");
        }
    }
}

LongRangeSensorsComponent.FullyFunctionalHealth = .8;


class PhaserControlComponent extends ShipComponent
{
    constructor()
    {
        super ("Phaser Control", .0625);
    }

    canFire()
    {
        return this.componentHealth >= PhaserControlComponent.DisabledThreshold;
    }

    phaserAccuracy()
    {
        let t = Math.min(this.componentHealth / PhaserControlComponent.FullyFunctionalHealth, 1.0);
        return (1.0 - t) * PhaserControlComponent.MinAccuracy + t; //lerp
    }

    isHit()
    {
        return Math.random() <= this.phaserAccuracy();
    }

    damageReport()
    {
        gameOutputAppend("Phasers Operable : " + (this.canFire() ? "YES" : "NO"));
        gameOutputAppend("Phaser Accuracy : " + (100*this.phaserAccuracy()) + "%");
    }
}

PhaserControlComponent.DisabledThreshold = .5;
PhaserControlComponent.FullyFunctionalHealth = .75;
PhaserControlComponent.MinAccuracy = .5;


class PhotonTubesComponent extends ShipComponent
{
    constructor()
    {
        super ("Photon Tubes", .125);
    }

    canFire()
    {
        return this.componentHealth > PhotonTubesComponent.DisabledThreshold;
    }

    targetingAvailable()
    {
        return this.componentHealth > PhotonTubesComponent.DamagedThreshold;
    }

    damageReport()
    {
        if (this.canFire())
        {
            if (!this.targetingAvailable())
            {
               gameOutputAppend("Due to damage, torpedo targeting computer is nonfunctional.  You will need to input torpedo trajectories manually until the system is repaired.");
            }

            gameOutputAppend("Torpedo Accuracy : " + (100 * this.torpedoAccuracy()) + "%");
        }
        else
        {
            gameOutputAppend("Torpedo tubes too damaged to fire.");
        }
    }

    torpedoAccuracy()
    {
        let t = (this.componentHealth - PhotonTubesComponent.DisabledThreshold) / (PhotonTubesComponent.DamagedThreshold - PhotonTubesComponent.DisabledThreshold);
        t = Math.min(t, 1.0);
        return (1.0 - t) * PhotonTubesComponent.MinAccuracy + t;
    }

    isHit()
    {
        return Math.random() <= this.torpedoAccuracy();
    }
}

PhotonTubesComponent.MinAccuracy = .25;         // 25% chance to hit minimum for torpedoes
PhotonTubesComponent.DamagedThreshold = .5;     // 50% health = automatic targeting is down.
PhotonTubesComponent.DisabledThreshold = .25;   // 25% health = can't fire torpedoes.

// make the shield scan thing conditional.  in both places.
class ShieldControlComponent extends ShipComponent
{
    constructor()
    {
        super ("Shield Control", .125);
    }

    maxShields()
    {
        let t = Math.min(1.0, this.componentHealth / ShieldControlComponent.FullyFunctionalHealth);

        return Math.round((1.0 - t) * ShieldControlComponent.MinShields + (t * ShieldControlComponent.MaxShields));
    }

    passthroughDamage(enterprise, damage)
    {
        this.componentHealth -= Math.min(damage, this.componentHealth);

        if (enterprise.shields > this.maxShields())
        {
            enterprise.shields = this.maxShields();
            gameOutputAppend("Deflector shields hit!  Shield energy dropped to " + this.maxShields());
        }
    }

    damageReport()
    {
        gameOutputAppend("Deflector shield system can process " + this.maxShields() + " units of energy out of a possible " + ShieldControlComponent.MaxShields);
    }

    estimateAvailable()
    {
        return this.componentHealth >= ShieldControlComponent.ShowShieldEstimateHealth;
    }
}

ShieldControlComponent.MinShields = 0;
ShieldControlComponent.MaxShields = 2000; ///\todo calculate what kind of combat situations would minimally exceed this and prevent them in the generator
ShieldControlComponent.FullyFunctionalHealth = .8;
ShieldControlComponent.ShowShieldEstimateHealth = .6;

class LibraryComputerComponent extends ShipComponent
{
    constructor()
    {
        super ("Library Computer", .3125);
    }

    mapsAccessible()
    {
        return this.componentHealth > LibraryComputerComponent.MapsThreshold;
    }

    damageReportAvailable()
    {
        return this.componentHealth > LibraryComputerComponent.DamageReportThreshold;
    }

    damageReport()
    {
        if (!this.mapsAccessible())
        {
            gameOutputAppend("Ship computer is too damaged to access maps.");
        }
    }
}

LibraryComputerComponent.MapsThreshold = .25; // 25% health = can't access maps.
LibraryComputerComponent.DamageReportThreshold = .5; // 50% health = can't access damage report

// ------- Enterprise.js ------- 
class Enterprise extends GameObject
{
    canSeeEntity(entity)
    {
        return !this.components.ShortRangeSensors.isSectorCorrupt(entity.sectorX, entity.sectorY);
    }

    bombardPlanet(trekgame, planet)
    {
        console.assert(!planet.bombarded);

        if (this.torpedoes < TrekGame.BombardCost)
        {
            return false;
        }

        var klingonsMoved = 0;
        let klingonsToMove = Math.min(Math.min(Klingon.Instances, TrekGame.BombardReinforcementSize), trekgame.currentQuadrant.emptySquares());

        for (var q in trekgame.galaxyMap.contents)
        {
            let quadrant = trekgame.galaxyMap.lookup1D(q);
            let quadrantKlingons = quadrant.getEntitiesOfType(Klingon);

            if (quadrant == trekgame.currentQuadrant)
            {
                continue;
            }
            
            for (var i = 0; i < Math.min(klingonsToMove - klingonsMoved, quadrantKlingons.length); i++)
            {
                let k = quadrantKlingons[i];
                quadrant.removeEntity(k);
                trekgame.currentQuadrant.addEntityInFreeSector(k);
                klingonsMoved++;
            }
        }

        console.log("Klingons moved : " + klingonsMoved);

        this.torpedoes -= TrekGame.BombardCost;

        planet.bombard();
    }

    componentDamageProbabilities()
    {
        var probArray = [];

        for (var key in this.components)
        {
            console.log("" + this.components[key].componentDamageProbability);
            probArray.push(this.components[key].componentDamageProbability);
        }

        console.assert(probArray.length == Object.keys(this.components).length);
        return probArray;
    }

    createComponents()
    {
        this.components =
        {
            WarpEngines : new WarpEnginesComponent(), 
            ShortRangeSensors: new ShortRangeSensorsComponent(),
            LongRangeSensors: new LongRangeSensorsComponent(),
            PhaserControl : new PhaserControlComponent(),
            PhotonTubes : new PhotonTubesComponent(),
            ShieldControl : new ShieldControlComponent(), 
            LibraryComputer : new LibraryComputerComponent()
        }
    }
    
    constructor()
    {
        super(Enterprise);
        this.torpedoes = Enterprise.StartTorpedoes;
        this.shields = Enterprise.StartShields;

        this.freeEnergy = Enterprise.StartEnergy;

        this.createComponents();

        this.hitNoShields = false;
        this.dockStarbase = null;
        this.sensorHistory = new SensorHistory();
        this.components.ShortRangeSensors.generateCorruptGrid();
    }

    // called on navigation
    autoRepairComponents()
    {
        for (var key in this.components)
        {
            let oldHealth = this.components[key].componentHealth;
            this.components[key].componentHealth += (randomInt(Enterprise.MinComponentRepairPerTurn, Enterprise.MaxComponentRepairPerTurn) / 100);
            this.components[key].componentHealth = Math.min(this.components[key].componentHealth, 1.0);

            if (this.components[key].componentHealth == 1.0 && oldHealth != 1.0)
            {
                gameOutputAppend("\n" + this.components[key].componentName + " fully repaired!");
            }
        }
    }

    repairRandomComponent()
    {
        var damagedComponents = [];

        for (var key in this.components)
        {
            if (this.components[key].componentHealth != 1.0)
            {
                damagedComponents.push(this.components[key]);
            }
        }

        console.log("Enterprise has " + damagedComponents.length + " damaged components");

        if (!damagedComponents.length)return;

        let componentToRepair = damagedComponents[randomInt(0, damagedComponents.length-1)];
        componentToRepair.componentHealth = 1.0;

        gameOutputAppend("\n"+componentToRepair.componentName + " has been fully repaired!");
    }

    undock(starbase)
    {
        this.dockStarbase = null;
    }

    dockWithStarbase(starbase)
    {
        console.log("dock with starbase");

        this.torpedoes = Enterprise.StartTorpedoes;
        this.freeEnergy = Enterprise.StartEnergy - this.shields;
        this.dockStarbase = starbase;

        gameOutputAppend("\nDocked with starbase.  Torpedoes and energy replenished.  The starbase's shields protect the Enterprise.");

        this.repairRandomComponent();
    }

    // is our total energy less than the minimum energy cost to get anywhere?
    isStranded()
    {
        return (this.freeEnergy + this.shields) < this.warpEnergyCost(1); // energy cost to travel one square.
    }

    isDestroyed()
    {
        return this.hitNoShields;
    }

    // suggested minimum shield level for the current battlefield, to survive at least one round of enemy fire
    suggestedMinShieldLevel(enemyList)
    {
        let possibleDamageSum = 0.0;

        for (var x in enemyList)
        {
            possibleDamageSum += enemyList[x].maxPhaserDamage();
        }

        return possibleDamageSum;
    }

    // is it possible for a single round of enemy fire to destroy the enterprise?
    isShieldLevelCritical(enemyList)
    {
        return !this.dockStarbase && (this.shields < this.suggestedMinShieldLevel(enemyList));
    }

    warpEnergyCost(numSectors)
    {
        return Enterprise.EnergyCostPerSector * numSectors;
    }
    
    // assumes that the input value has been previously checked for the appropriate range and available value
    setShieldLevel(newShields)
    {
        if ((newShields > this.freeEnergy + this.shields) || newShields < 0.0)
        {
            throw "Invalid value for shield level"; 
        }

        let adjustedShields = Math.min(this.components.ShieldControl.maxShields(), newShields);

        if (!(adjustedShields > 0))
        {
            gameOutputAppend("Sorry captain, we've taken too much damage to raise shields!");
        }
        if ((adjustedShields < newShields))
        {
            if ( (adjustedShields < ShieldControlComponent.MaxShields))
            {
                gameOutputAppend("\nBecause of damage to the deflector shields, we cannot raise shields above " + adjustedShields);
            }
            else
            {
                gameOutputAppend("\nCannot exceed the maximum shield level of " + adjustedShields);
            }

            newShields = adjustedShields;
        }

        this.freeEnergy += this.shields - newShields;
        this.shields = newShields;

        gameOutputAppend("\nShields set to " + this.shields + ".  " + this.freeEnergy + " free energy remaining.");
    }

    toString()
    {
        return "<*>";
    }

    static maxInstancesGame()
    {
        return 1;
    }

    static maxInstancesQuadrant()
    {
        return 1;
    }

    static minInstancesGame()
    {
        return 1;
    }

    conditionString(game)
    {
        if (game.currentQuadrant.countEntitiesOfType(Klingon))
        {
            return "RED";
        }

        if ((this.freeEnergy + this.shields) < .1 * Enterprise.StartEnergy)
        {
            return "YELLOW";
        }

        return "GREEN";
    }

    passthroughDamage(energy)
    {
        // we want to map (as a starting guess, pre balance) 500 energy to a total wipeout of a component
        let passthroughDamage = energy * randomFloat(.001, .002);

        // random component index
        let idx = randomWithProbabilities(this.componentDamageProbabilities());

        let component = this.components[Object.keys(this.components)[idx]];

        component.passthroughDamage(this, passthroughDamage);

        gameOutputAppend(component.componentName + " hit.  Now at " + Math.floor(component.componentHealth*100) + "% integrity" );
    }

    onPhaserHit(energy, game)
    {
        if (this.dockStarbase)
        {
            gameOutputAppend("The starbase shields protect you from the incoming phaser fire.");
            return;
        }

        let hitRatio = energy / this.shields;

        if (this.shields < energy)
        {
            this.hitNoShields = true;
            this.shields = 0.0;

            return;
        }

        this.shields -= energy;
        gameOutputAppend("Shields at " + this.shields);

        if ((hitRatio > Enterprise.DamagePassthroughRatio) || Math.random() < Enterprise.RandomPassthroughRatio)
        {
            this.passthroughDamage(energy);
        }        
    }

    firePhasers(energy, game)
    {
        console.log("fire phasers");

        let targets = [];

        var x;
        for (x in Enterprise.PhaserTargets)
        {
            targets.push(...game.currentQuadrant.getEntitiesOfType(Enterprise.PhaserTargets[x]));
        }

        let enterprise = this;
        let targetsFiltered = targets.filter(function(item){return enterprise.canSeeEntity(item)});

        console.assert(energy <= this.freeEnergy);

        if (!targetsFiltered.length)
        {
            gameOutputAppend("\nUnable to lock phasers onto targets because of sensor damage!");
            return false;
        }

        this.freeEnergy -= energy;

        let endstr = targetsFiltered.length > 1 ? "s." : ".";
        gameOutputAppend("\nFiring phasers at " + targetsFiltered.length + " target" + endstr);
        
        let invisibleEnemies = targets.length - targetsFiltered.length;
        if (invisibleEnemies > 1)
        {
            gameOutputAppend("" + invisibleEnemies + " enemies not able to be targeted due to sensor damage!");
        }
        else if (invisibleEnemies == 1)
        {
            gameOutputAppend("" + 1 + " enemy not able to be targeted due to sensor damage!");
        }
      
        let damagePerTarget = energy / targetsFiltered.length;

        var x;
        for (x in targetsFiltered)
        {
            console.log("target");
            let target = targetsFiltered[x];
            let dist = this.distanceToObject(target);

            let damageAttenuated = damagePerTarget / dist;
            let damageFinal = Math.floor(randomFloat(2.0, 3.0) * damageAttenuated);

            if (this.components.PhaserControl.isHit())
            {
               target.onPhaserHit(damageFinal, game);
            }
            else
            {
                gameOutputAppend("Phasers miss!");
            }
        }

        if (!game.currentQuadrantScanned)
        {
            gameOutputAppend("\nRun combat sensor scan to see enemy shield levels.");
        }

        return true;
    }

    fireTorpedo(game, target)
    {
        if (this.freeEnergy >= Enterprise.TorpedoEnergyCost)
        {
            gameOutputAppend("\nFiring torpedoes towards subsector " + target.sectorString());
            let torpedoIntersection = game.currentQuadrant.intersectionTest(this.sectorX, this.sectorY, target.sectorX, target.sectorY, Infinity);
            this.torpedoes--;
            this.freeEnergy -= Enterprise.TorpedoEnergyCost;
            
            if (this.components.PhotonTubes.isHit() && torpedoIntersection.intersects != null)
            {
               torpedoIntersection.intersects.onTorpedoHit(game);
            }
            else
            {
                gameOutputAppend("\nThe torpedo missed!");
            }
        }
        else
        {
            //not enough energy
            gameOutputAppend("\nNot enough energy to fire torpedoes!");
        }
    }

    lrsStringEntityType(galaxyMap, entityType)
    {
        let header = "   ";
        for (let x = this.quadrantX - 1; x <= this.quadrantX + 1; x++)
        {
            header += padStringToLength((""+(x+1)), 6);
        }

        let border = "-------------------";
        let rval = header + "\n   " + border + '\n';

        for (let y = this.quadrantY - 1; y <= this.quadrantY + 1; y++)
        {
            rval += " " + (y+1) + " |";
            for (let x = this.quadrantX - 1; x <= this.quadrantX + 1; x++)
            {
                let quadrant = galaxyMap.lookup(x, y);
                if (quadrant)
                {
                    let k = quadrant.countEntitiesOfType(entityType);

                    if (x == this.quadrantX && y == this.quadrantY)
                    {
                        k = "" + k + "E";
                    }

                    rval += " " + padStringToLength(""+k, 3) + " |";
                }
                else
                {
                    rval += " *** |";
                }
            }
            rval += "\n   " + border + "\n";
        }
        return rval;
    }

    // long range scan
    lrsString(trekGame, galaxyMap)
    {
        let rval = trekGame.primeUniverse ? "\t KLINGONS" : "\t ENEMIES";
        
        rval += "\t\t  STARS\t\t\tSTARBASES\n";

        let klingonLRS = this.lrsStringEntityType(galaxyMap, Klingon);
        let starLRS = this.lrsStringEntityType(galaxyMap, Star);
        let starbaseLRS = this.lrsStringEntityType(galaxyMap, StarBase);

        let klingonLRSLines = klingonLRS.split('\n');
        let starLRSLines = starLRS.split('\n');
        let starbaseLRSLines = starbaseLRS.split('\n');

        console.assert(klingonLRSLines.length == starLRSLines.length);
        for (var x in klingonLRSLines)
        {
            rval += klingonLRSLines[x] + "\t" + starLRSLines[x] + "\t" + starbaseLRSLines[x] + '\n';
        }

        return rval;
    }

    warp(sectorXEnd, sectorYEnd, sectorsToTravel, game)
    {
        let energyRequired = this.warpEnergyCost(sectorsToTravel);

        if (this.freeEnergy < energyRequired)
        {
            gameOutputAppend("\nNot enough energy free to complete maneuver!");
            return false;
        }

        let intersection = game.currentQuadrant.intersectionTest(this.sectorX, this.sectorY, sectorXEnd, sectorYEnd)
           
        this.sectorX = Math.floor(intersection.lastX);
        this.sectorY = Math.floor(intersection.lastY);

        if (intersection.intersects != null)
        {
            gameOutputAppend("\nObstruction ahead.  Shutting down warp engines.");
        }

        if (!intersection.stepIterations)
        {
            return false;
        }

        let actualEnergy = this.warpEnergyCost(intersection.stepIterations);

        // get the energy cost of the sectors we actually travelled
        this.freeEnergy -= actualEnergy;

        return true;
    }

    damageReport()
    {
        if (!this.components.LibraryComputer.damageReportAvailable())
        {
            gameOutputAppend("\nDamage report unavailable due to computer damage!");
            return;
        }

        gameOutputAppend("\nDAMAGE REPORT:\n");
        gameOutputAppend("Component Integrity:")
        for (var key in this.components)
        {
            let component = this.components[key];
            gameOutputAppend("" + component.componentName + " : " + Math.round(component.componentHealth * 100) + "%");
        }

        gameOutputAppend("\n\nNOTES:\nRepair crews can repair 1-5% damage per stardate.  A starbase will fully repair a single component every stardate.");

        for (var key in this.components)
        {
            let component = this.components[key];
            component.damageReport();
        }
    }

    static ConstructFromJSData(jsData)
    {
        let rval = Object.create(Enterprise.prototype);
        Object.assign(rval, jsData);

        rval.sensorHistory = new SensorHistory();
        Object.assign(rval.sensorHistory, jsData.sensorHistory);

        rval.createComponents();

        for (var key in rval.components)
        {
            Object.assign(rval.components[key], jsData.components[key]);
        }

        rval.components.ShortRangeSensors.corruptGrid = new Grid();
        rval.components.ShortRangeSensors.corruptGrid.contents = jsData.components.ShortRangeSensors.corruptGrid.contents;

        return rval;
    }
}

Enterprise.StartTorpedoes = 10;
Enterprise.StartEnergy = 3000;
Enterprise.StartShields = 0;
Enterprise.TorpedoEnergyCost = 10;
Enterprise.EnemyScanCost = 10;
Enterprise.PhaserTargets = [Klingon];           // future extension : this list could be dynamic based on evolving gameplay alliances, etc :) 
Enterprise.EnergyCostPerSector = 1.0;           // Warp cost per sector moved
Enterprise.EnergyCostPerQuadrant = 10.0;        // Warp cost per quadrant moved
Enterprise.DamagePassthroughRatio = .25;        // if damage is 25% of shields or more, pass damage through to components
Enterprise.RandomPassthroughRatio = .25;        // 25% chance that damage will pass through to ship components regardless of shields
Enterprise.MinComponentRepairPerTurn = 1;       // integrity min autorepair per component
Enterprise.MaxComponentRepairPerTurn = 5;       // integrity max autorepair per component


// ------- Quadrant.js ------- 
class Quadrant
{
    constructor(widthSectorsIn, heightSectorsIn, x, y)
    {
        checkArgumentsDefinedAndHaveValue(arguments);
        this.width = widthSectorsIn;
        this.height = heightSectorsIn;
        this.quadrantEntities = new Array();
        this.x = x;
        this.y = y;
    }

    populateFromJSData(entitiesQuadrantJS)
    {
        var x;
        for (x in entitiesQuadrantJS.quadrantEntities)
        {
            let entData = entitiesQuadrantJS.quadrantEntities[x];

            // we construct and insert the enterprise entity elsewhere.
            if (entData.entityType != "Enterprise")
            {
                let ctype = EntityMap.get(entData.entityType);

                let entityObj = new ctype(); 
                Object.assign(entityObj, entData);

                this.quadrantEntities.push(entityObj);
            }
        }
    }

    removeEntity(entity)
    {
        let rmindex = this.quadrantEntities.indexOf(entity);
        if (rmindex == -1)throw "Entity not found";
        this.quadrantEntities.splice( rmindex, 1 );
    }

    entityAtLocation(nextXCoord, nextYCoord)
    {
        nextXCoord = Math.floor(nextXCoord);
        nextYCoord = Math.floor(nextYCoord);
        
        for (var x in this.quadrantEntities)
        {
            let objTest = this.quadrantEntities[x];

            if ((objTest.sectorX == nextXCoord) && (objTest.sectorY == nextYCoord))
            {
                return objTest;
            }
        }

        return null;
    }

    // return a tuple containing
    // the last sector prior to the intersection
    // and the intersection object (null if none)
    intersectionTest(sectorX, sectorY, sectorXEnd, sectorYEnd, maxT = 1.0)
    {
        checkArgumentsDefinedAndHaveValue(arguments);

        // polar to euclidean coordinates
        let xVec = sectorXEnd - sectorX;
        let yVec = sectorYEnd - sectorY;

        // we'll step through the grid in in increments of one cell; -1 if the x / y direction are negative
        let xNextF = xVec > 0.0 ? 1.0 : -1.0;
        let yNextF = yVec > 0.0 ? 1.0 : -1.0;

        // start in the middle of the cell.
        let startCoordX = Math.floor(sectorX) + .5;
        let startCoordY = Math.floor(sectorY) + .5;
        let endCoordX = Math.floor(sectorXEnd) + .5;
        let endCoordY = Math.floor(sectorYEnd) + .5;

        // return values
        let lastCellBeforeIntersectionX = startCoordX;
        let lastCellBeforeIntersectionY = startCoordY;
        let intersectionObject = null;

        //console.log("start coord " + (startCoordX) + " " + (startCoordY));
        //console.log("end coord " + (endCoordX) + " " + (endCoordY));
        //console.log("vec " + (xVec) + " " + (yVec));

        var nextXCoord = 0;
        var nextYCoord = 0;

        let currentT = 0.0;

        var steps = 0;
        while (true)
        {
            // we have, given a start coordinate and a direction vector, the parametric equation of a line
            // Pt = P0 + D*t
            // From this we can derive the parameter t at which the line will reach a particular X or Y value
            // X_t = X_0 + V_x * t
            // Y_t = Y_0 + V_y * t
            // implies
            // (X_t - X_0) / V_x = t
            // or
            // (Y_t - Y_0) / V_y = t
            // so we can figure out what the next cell on the x axis is (current plus or minus one) and figure
            // out the t parameter where the line crosses it.  
            // We can do the same for the next call on the y axis.
            // Then, whichever cell has the lower t parameter the line crosses first.
            // Because there's a division and it's possible the direction vector has a zero component, we'll check for divide by zero

            nextXCoord = Math.floor(lastCellBeforeIntersectionX + xNextF);
            nextYCoord = Math.floor(lastCellBeforeIntersectionY + yNextF);

            //console.log("next " + nextXCoord + " " + nextYCoord);

            let tXBound = ((nextXCoord+.5) - startCoordX) / xVec;
            let tYBound = ((nextYCoord+.5) - startCoordY) / yVec;

            tXBound = Math.abs(xVec) > .00001 ?  tXBound : Number.MAX_VALUE;
            tYBound = Math.abs(yVec) > .00001 ?  tYBound : Number.MAX_VALUE;

            if (tXBound < tYBound) // hit the x boundary first.
            {
                //console.log("xb " + tXBound);
                currentT = tXBound;
                nextYCoord = startCoordY + yVec * currentT;
            }
            else
            {
                //console.log("yb");
                currentT = tYBound;
                nextXCoord = startCoordX + xVec * currentT;
            }

            if (currentT > maxT)
            {
                //console.log("Exceeded jump range "+ currentT);
                break;
            }

            intersectionObject = this.entityAtLocation(nextXCoord, nextYCoord);

            if (intersectionObject != null)
            {
                //console.log("intersection return");
                break;
            }

            if (nextXCoord < 0 || nextXCoord >= quadrantWidthSectors || nextYCoord < 0 || nextYCoord >= quadrantHeightSectors)
            {
                //console.log("next out of bounds " + nextXCoord + " " + nextYCoord);
                break;
            }

            //console.log("T is at " + currentT);
            lastCellBeforeIntersectionX = nextXCoord;
            lastCellBeforeIntersectionY = nextYCoord;

            steps++;

            //console.log("cell step" + (lastCellBeforeIntersectionX) + " " + (lastCellBeforeIntersectionY));
        }

        //console.log("cell end " + (lastCellBeforeIntersectionX) + " " + (lastCellBeforeIntersectionY)+ " " + intersectionObject);
        return {lastX : lastCellBeforeIntersectionX, lastY : lastCellBeforeIntersectionY, intersects : intersectionObject, stepIterations:steps, nextX : nextXCoord, nextY : nextYCoord};
    }

    countEntitiesOfType(classtype)
    {
        var rval=0;
        for (var x in this.quadrantEntities)
        {
            if (this.quadrantEntities[x].constructor == classtype)
            {
                rval++;
            }
        }
        return rval;
    }

    getEntitiesOfType(classtype)
    {
        return this.quadrantEntities.filter(function(item){return item.constructor == classtype});
    }

    getAdjacentEntitiesOfType(adjacentToObj, classtype)
    {
        let sblist = this.getEntitiesOfType(classtype);
        return sblist.filter(function(sb){return sb.isAdjacentTo(adjacentToObj)});
    }

    klingonsFire(target, game)
    {
        let klist = this.getEntitiesOfType(Klingon);

        let descStr = game.primeUniverse ? "Klingon" : "Federation";
        if (klist.length > 1)
        {
            gameOutputAppend("\nThe " + descStr + " vessels fire their phasers.");
        }
        else if (klist.length)
        {
            gameOutputAppend("\nThe " + descStr + " vessel fires its phasers.");
        }

        for (var x in klist)
        {
            klist[x].firePhasers(target, game);
        }
    }

    createEntities(entityTypes)
    {
        var entityIdx;
        for (entityIdx in entityTypes)
        {
            let entityType = entityTypes[entityIdx];

            let numEntities = entityType.randomCountForQuadrant(this.emptySquares(), this.countEntitiesOfType(entityType));

            for (let i =0; i < numEntities; i++ )
            {
                var ent = new entityType();
                this.addEntityInFreeSector(ent);
            }
        }
    }

    addEntityInFreeSector(entity)
    {
        entity.quadrantX = this.x;
        entity.quadrantY = this.y;
        entity.setLocationSector(this.getEmptySquare());
        this.quadrantEntities.push(entity);
    }

    addEntity(entity)
    {
        entity.quadrantX = this.x;
        entity.quadrantY = this.y;

        this.quadrantEntities.push(entity);
    }

    emptySquares()
    {
        return this.width*this.height - this.quadrantEntities.length;
    }

    getEmptySquare()
    {
        console.assert(this.width * this.height > this.quadrantEntities.length);

        if (this.quadrantEntities.length >= this.width*this.height)
        {
            return null;
        }

        let emptyFound = false;

        let testRandom = randomInt(0, (this.width*this.height)-1);

        while (!emptyFound)
        {
            let randomX = testRandom % this.width;
            let randomY = Math.floor(testRandom / this.height);

            var entityIdx;
            emptyFound = true;
            for (entityIdx in this.quadrantEntities)
            {
                let entity = this.quadrantEntities[entityIdx];
                if (entity.sectorX == randomX && entity.sectorY == randomY)
                {
                    emptyFound = false;
                    break;
                }
            }

            if (emptyFound)
            {
                return {x : randomX, y : randomY};
            }

            testRandom++;
        }
    }

    toString()
    {
        let borderStringPost = "   " + mapFooter(quadrantWidthSectors) + '\n';
        let borderStringPre = "   " + mapHeader(quadrantWidthSectors); 

        let quadrantStringGrid = new Grid(this.width, this.height, function(){return " ".padStart(sectorDisplayWidthChars, ' ')})

        var gameObjectIndex;
        for (gameObjectIndex in this.quadrantEntities)
        {
            let gameObject = this.quadrantEntities[gameObjectIndex];
            let objStr = gameObject.toString().padStart(sectorDisplayWidthChars, ' ');
            quadrantStringGrid.setValue(gameObject.sectorX, gameObject.sectorY, objStr);
        }

        let mapString = quadrantStringGrid.toString();

        return "<pre>" + borderStringPre + mapString + borderStringPost + "</pre>";
    }
}

// ------- GalaxyMap.js ------- 
class GalaxyMap extends Grid
{
    constructor(quadrantsX, quadrantsY, entityTypes)
    {
        checkArgumentsDefinedAndHaveValue(arguments);
        super(quadrantsX, quadrantsY, function(x, y){return new Quadrant(quadrantWidthSectors,quadrantHeightSectors, x, y)});

        this.createMinimumInstances(entityTypes, quadrantsX, quadrantsY);

        for (let i = 0; i < quadrantsX*quadrantsY; i++)
        {
            this.lookup1D(i).createEntities(entityTypes);
        }
    }

    static ConstructFromJSData(jsData)
    {
        let rval = new GalaxyMap(mapWidthQuadrants, mapHeightQuadrants, []);

        var x;
        for (x in jsData.contents)
        {
            let entitiesQuadrantJS = jsData.contents[x];

            rval.contents[x].populateFromJSData(entitiesQuadrantJS);
        }

        return rval;
    }

    mapString(galaxyMap, EntityType = Klingon, gameobject = null)
    {
        let header = "   ";
        for (let x = 0; x < mapWidthQuadrants; x++)
        {
            header += padStringToLength((""+(x+1)), 6);
        }

        let border = "------";
        border = border.repeat(mapWidthQuadrants);
        let rval = header + "\n   " + border + '\n';

        for (let y = 0; y < mapHeightQuadrants; y++)
        {
            rval += " " + (y+1) + " |";
            for (let x = 0; x < mapWidthQuadrants; x++)
            {
                let quadrant = galaxyMap.lookup(x, y);
                
                if (quadrant)
                {    
                    let k = quadrant.countEntitiesOfType(EntityType);

                    if (gameobject)
                    {
                        if (gameobject.quadrantX == x && gameobject.quadrantY == y)
                        {
                            // put an "E" on the map for the enterprise's current location
                            k += 'E';
                        }
                    }

                    rval += " " + padStringToLength(""+k, 3, ' ') + " |";
                }
                else
                {  console.log(" null");
                    rval += " *** |";
                }
             }
             rval += "\n   " + border + "\n";
         }
         return rval;
    }

    createMinimumInstances(entityTypes)
    {
        var x;
        for (x in entityTypes)
        {
            let etype = entityTypes[x];

            let instancesToCreate = etype.minInstancesGame() ;//- etype.Instances;

            // console.log("Creating min instances of " + etype.name + " : " + instancesToCreate);
            if (instancesToCreate > 0)
            {
                for (let i = 0; i < instancesToCreate; i++)
                {
                    let inst = new etype();
                    let randomQuadrant = randomInt(0, this.contents.length-1);

                    let instAssigned = false;
                    for (let quad = 0; quad < this.contents.length; quad++)
                    {
                        if (this.lookup1D(randomQuadrant).emptySquares())
                        {
                            this.lookup1D(randomQuadrant).addEntityInFreeSector(inst);
                            instAssigned = true;
                            break;
                        }

                        randomQuadrant = (randomQuadrant + 1 ) % this.contents.length;
                    }
                    
                    if (!instAssigned)
                    {
                        throw "Not enough space to assign minumum instances of " + etype.name;
                    }
                }
            }
        }
    }
}

// ------- SensorHistory.js ------- 
class SensorHistory extends Grid
{
    constructor()
    {
        super( mapWidthQuadrants, mapHeightQuadrants, function(){return {};} );
    }

    updateSensorHistory(EntityType, galaxyMap, startLocX, startLocY, endLocX, endLocY)
    {
        for (var y = startLocY; y <= endLocY; y++)
        {
            for (var x = startLocX; x <= endLocX; x++)
            {
                let quadrant = galaxyMap.lookup(x, y);

                if (quadrant)
                {
                    let ct = quadrant.countEntitiesOfType(EntityType);
                    this.lookup(x, y)[EntityType] = ct;
                }
            }
        }               
    }

    updateSensorHistoryForEntityTypes(EntityList, galaxyMap, startLocX, startLocY, endLocX, endLocY)
    {
        for (var x in EntityList)
        {
            let EntityType = EntityList[x];
            this.updateSensorHistory(EntityType, galaxyMap, startLocX, startLocY, endLocX, endLocY);
        }
    }

    mapString(EntityType = Klingon, gameobject = null)
    {
        let header = "   ";
        for (let x = 0; x < mapWidthQuadrants; x++)
        {
            header += padStringToLength((""+(x+1)), 6);
        }

        let border = "------";
        border = border.repeat(mapWidthQuadrants);
        let rval = header + "\n   " + border + '\n';

        for (let y = 0; y < this.height; y++)
        {
            rval += " " + (y+1) + " |";
            for (let x = 0; x < this.width; x++)
            {
                let quadrantDict = this.lookup(x, y);
                
                if (quadrantDict)
                {    
                    var k = "";

                    if (EntityType in quadrantDict)
                    {
                        k += quadrantDict[EntityType]; // integer count of the entity type
                    }
                    else
                    {
                        k += "?";
                    }

                    if (gameobject)
                    {
                        if (gameobject.quadrantX == x && gameobject.quadrantY == y)
                        {
                            // put an "E" on the map for the enterprise's current location
                            k += 'E';
                        }
                    }

                    rval += " " + padStringToLength(""+k, 3, ' ') + " |";
                }
                else
                {  console.log(" null");
                    rval += " *** |";
                }
             }
             rval += "\n   " + border + "\n";
         }
         return rval;
     }
}

// ------- Menu.js ------- 
class MenuOption
{
    constructor(option, separator, description, payload)
    {
        this.option = option.toString();
        this.separator = separator;
        this.description = description;
        this.payload = payload;
        this.enabled = true;
    }

    compare(testString)
    {
        return testString.toLowerCase() == this.option.toLowerCase();
    }

    toString()
    {
        return this.option + this.separator + this.description + '\n';
    }
}

class Menu
{
    constructor()
    {
        this.options = [];
        this.headerString = "ENTER ONE OF THE FOLLOWING:\n";
    }

    getSelectedOption(optionText)
    {
        for (var x in this.options)
        {
            if (this.options[x].compare(optionText) && this.options[x].enabled)
            {
                return this.options[x];
            }
        }
        return null;
    }

    invalidOption()
    {
        gameOutputAppend("Come again, captain?");
        return false;
    }

    chooseOption(optionText)
    {
        var menuopt = this.getSelectedOption(optionText);
        if (menuopt)
        {
            return menuopt.payload();
        }
        return this.invalidOption(optionText);
    }

    toString()
    {
        return Menu.TypingFree ? this.toStringHyperlink() : this.toStringTyping();
    }

    toStringTyping()
    {
        var rstring = this.headerString;

        for (var x in this.options)
        {
            if (this.options[x].enabled)
            {
                rstring += this.options[x];
            }
        }

        return rstring;
    }

    toStringHyperlink()
    {
        var rstring = this.headerString;

        for (var x in this.options)
        {
            if (this.options[x].enabled)
            {
                let sb = "<pre><a href=\"javascript:game.gameInput('" + this.options[x].option + "');\"  style=\"color: rgb(0,255,0)\">";
                let sa = "</a></pre>"
                rstring += sb + this.options[x] + sa;
                console.log(sb + this.options[x] + sa);
            }
        }

        return rstring;
    }
}

Menu.TypingFree = false;

// ------- MainMenu.js ------- 
class MainMenu extends Menu
{
    constructor(trekgame)
    {
        super();

        this.options = [];

        this.options.push
        (
            new MenuOption
            (
                "0",
                ") ",
                "DOCK WITH STARBASE",
                function()
                {
                    let adjacentStarbases = trekgame.currentQuadrant.getAdjacentEntitiesOfType(trekgame.enterprise, StarBase);
                    console.assert(adjacentStarbases.length);

                    let sb = adjacentStarbases[0];

                    trekgame.enterprise.dockWithStarbase(sb);

                    trekgame.showDockMenu(sb);

                    trekgame.advanceStardate(1.0);

                    return false;
                }
            ),
            new MenuOption
            (
                "0",
                ") ",
                "BOMBARD PLANET ("+TrekGame.BombardCost+" TORPEDOES)",
                function()
                {

                    let bombardPrompt = "\nWhile in orbit around the planet, your scanners detected a base established by enemies of the empire.";
                    bombardPrompt += "\nYou could bombard the base to lure enemy ships into the sector.  Make sure you're prepared, because a large ";
                    bombardPrompt += "number of ships may deploy to the sector!";

                    gameOutputAppend(bombardPrompt);

                    let confirmMenu = new Menu();

                    confirmMenu.options.push
                    (
                        new MenuOption
                        (
                            "1", ") ", "BOMBARD THE PLANET (" + TrekGame.BombardCost + " TORPEDOES)", function(){trekgame.bombardPlanet(); return true;}
                        ),
                        new MenuOption
                        (
                            "2", ") ", "NEVER MIND", function(){return true;}
                        )
                    );

                    trekgame.awaitInput
                    (
                        confirmMenu.toString(),
                        1,
                        function(inputline){return confirmMenu.chooseOption(inputline);}
                    );

                    return false;
                }
            ),
            new MenuOption
            (
                "1",
                ") ",
                "NAVIGATION",
                function()
                {
                    let navigationMenu = new Menu();
                    navigationMenu.options.push
                    (
                        new MenuOption
                        (
                            "1",
                            ") ",
                            "SHORT RANGE JUMP (1 STARDATE)",
                            function()
                            {
                                if (trekgame.typingFree)
                                {
                                    trekgame.gridHandler = function(x,y){trekgame.shortRangeNavigationHandler(trekgame, x, y);}
                                    trekgame.showBackMenu("SELECT DESTINATION ON THE MAP");
                                    return false;
                                }
                                else
                                {
                                    trekgame.getSubsectorMenu(trekgame.shortRangeNavigationHandler);
                                }
                                return false;
                            }
                        ),
                        new MenuOption
                        (
                            "2",
                            ") ",
                            "JUMP TO ANOTHER SECTOR  (1 STARDATE)",
                            function()
                            {
                                if (trekgame.typingFree)
                                {
                                    trekgame.mapScreenGalaxy = true;
                                    trekgame.gridHandler = function(x,y)
                                    {
                                        trekgame.longRangeJump(x,y);
                                    }

                                    trekgame.showBackMenu("SELECT DESTINATION SECTOR ON THE GALAXY MAP");
                                    return false;
                                }
                                else
                                {
                                    trekgame.awaitInput("Enter destination sector X coordinate. Enter a value between 1 and " + mapWidthQuadrants, 2, trekgame.navigationHandlerLongRangeX);
                                }
                                return false;
                            }
                        ),
                        new MenuOption
                        (
                            "3", ") ", "BACK", function(){return true;}
                        )
                    );

                    trekgame.awaitInput(navigationMenu.toString(), 1, function(inputline){return navigationMenu.chooseOption(inputline);});

                    //trekgame.awaitInput("Enter heading (degrees).", 3, trekgame.navigationHandler);
                }
            ), 

            new MenuOption
            (
                "2", ") ", "WEAPONS",
                function()
                {
                    MainMenu.showWeaponsMenu(trekgame);
                }
            ),

            new MenuOption
            (
                "3",
                ") ",
                "SHIELD CONTROL",
                function()
                {
                    let totalEnergy = (trekgame.enterprise.freeEnergy + trekgame.enterprise.shields);
                    
                    let suggestedStr = "";
                    if (trekgame.currentQuadrant.countEntitiesOfType(Klingon))
                    {
                        let klingonList = trekgame.currentQuadrant.getEntitiesOfType(Klingon);

                        let suggestedShieldLevel = trekgame.enterprise.suggestedMinShieldLevel(klingonList);

                        if (!trekgame.enterprise.components.ShieldControl.estimateAvailable())
                        {
                            suggestedShieldLevel = "?????";
                        }

                        suggestedStr += "\nSUGGESTED SHIELD LEVEL FOR CURRENT COMBAT SITUATION: " + suggestedShieldLevel;
                    }

                    let maxStr = "\nMAXIMUM SHIELD ENERGY: " + trekgame.enterprise.components.ShieldControl.maxShields();

                    let headerStr = "ENTER NEW SHIELD ENERGY LEVEL. \nAVAILABLE ENERGY: " + totalEnergy + maxStr + suggestedStr;

                    if (trekgame.typingFree)
                    {
                        let increment = trekgame.enterprise.components.ShieldControl.maxShields() / 5;
                        let shieldMenu = new Menu();
                        let maxShields = trekgame.enterprise.components.ShieldControl.maxShields();

                        shieldMenu.headerString = headerStr;

                        for (var x = 0; x < 6; x++)
                        {

                            let shieldAmount = x * increment;
                            let optionString = "SET SHIELD ENERGY TO " +shieldAmount + " ("+ (100*shieldAmount / maxShields) + '%)'; 

                            shieldMenu.options.push
                            (
                                new MenuOption
                                (
                                    x+1,
                                    ") ",
                                    optionString,
                                    function(){trekgame.shieldHandler("" + shieldAmount);return true;}
                                )
                            );
                        }

                        shieldMenu.options.push(new MenuOption("7", ") ", "TYPE IN MANUALLY", 
                            function()
                            {
                                trekgame.awaitInput(headerStr, 4, trekgame.shieldHandler, true);
                                return false;
                            }));
                        shieldMenu.options.push(new MenuOption("8", ") ", "BACK", function(){return true}));
                        trekgame.awaitInput(shieldMenu.toString(), 1, function(inputline){return shieldMenu.chooseOption(inputline);});
                    } 
                    else
                    {
                        trekgame.awaitInput(headerStr, 4, trekgame.shieldHandler);
                    }
                }
            ),

            new MenuOption
            (
                "4",
                ") ",
                "SENSORS",
                function()
                {
                    let enemyScanAddendum = trekgame.currentQuadrantScanned ? "" : " (" + Enterprise.EnemyScanCost + " ENERGY)";
                    let sensorMenu = new Menu();

                    sensorMenu.options.push
                    (
                        new MenuOption("1", ") ", "SCAN ENEMY SHIPS" + enemyScanAddendum, function(){trekgame.scanEnemyShips(); return true;}),
                        new MenuOption("2", ") ", "LONG RANGE SENSORS (1 STARDATE)", function(){trekgame.longRangeScan(); return true;}),
                        new MenuOption("3", ") ", "BACK", function(){return true;})
                    );

                    return trekgame.awaitInput(sensorMenu.toString(), 1, function(inputline){return sensorMenu.chooseOption(inputline);});
                }
            ),

            new MenuOption
            (
                "5",
                ") ",
                "SHIP'S COMPUTER",
                function()
                {
                    return trekgame.awaitInput(trekgame.computerMenu.toString(), 1, function(inputline){return trekgame.computerMenu.chooseOption(inputline);});
                }
            )
        );

        this.dockOption = this.options[0];
        this.dockOption.enabled = false;

        this.bombardOption = this.options[1];
        this.bombardOption.enabled = false;
    }

    static showWeaponsMenu(trekgame)
    {
        var weaponsMenu = new Menu();

        weaponsMenu.options.push(
        new MenuOption
            (
                "1",
                ") ",
                "PHASERS",
                function()
                {
                    if (!trekgame.enterprise.components.PhotonTubes.canFire())
                    {
                        gameOutputAppend("\nPhasers too damaged to fire!");
                        return true;
                    }
                    if (trekgame.currentQuadrant.countEntitiesOfType(Klingon))
                    {
                        if (trekgame.typingFree)
                        {
                            let pm = new PhaserMenu(trekgame);
                            trekgame.showMenu(pm);
                            return false;
                        }
                        else
                        {
                            return trekgame.manualPhaserEntry();
                        }
                    }
                    else
                    {
                        gameOutputAppend("\nPhaser control : No enemies detected in this sector, captain.");
                        return true;
                    }
                }
            ),

            new MenuOption
            (
                "2",
                ") ",
                "PHOTON TORPEDOES ("+Enterprise.TorpedoEnergyCost+" ENERGY)",
                function()
                {
                    if (trekgame.enterprise.torpedoes <= 0)
                    {
                        gameOutputAppend("\nWe're out of torpedoes, captain!");
                    }
                    else if (trekgame.enterprise.components.PhotonTubes.canFire())
                    {
                        if (trekgame.enterprise.components.PhotonTubes.targetingAvailable())
                        {
                            // automatic targeting enabled. push a menu of targets.
                            console.log("auto targeting path");

                            let torpMenu = new TorpedoMenu(trekgame.currentQuadrant.getEntitiesOfType(Klingon), trekgame);

                            trekgame.awaitInput(torpMenu.toString(), 1, function(inputline){return torpMenu.chooseOption(inputline);});
                        }
                        else
                        {
                            gameOutputAppend("\nDue to damage, torpedo targeting computer is nonfunctional.");
                            gameOutputAppend("You will have to enter the torpedo destination coordinates manually!");
                            trekgame.manualTorpedoHandler();
                        }
                    }
                    else
                    {
                        gameOutputAppend("Torpedo tubes too damaged to fire!");
                    }
                }
            ),

            new MenuOption("3", ") ", "BACK", function(){return true;})

        );

        return trekgame.awaitInput(weaponsMenu.toString(), 1, function(inputline){return weaponsMenu.chooseOption(inputline);});
    }

}



// ------- TorpedoMenu.js ------- 
class TorpedoMenu extends Menu
{
    constructor(targetList, trekgame)
    {
        super();

        this.options = [];

        for (var x = 0; x < targetList.length; x++)
        {
            let tgt = targetList[x];

            if (trekgame.enterprise.canSeeEntity(tgt))
            {
                this.options.push
                (
                    new MenuOption
                    (
                        x + 1,
                        ") ",
                        "TARGET AT SUBSECTOR ("+targetList[x].sectorString() + ")",
                        function()
                        {
                            trekgame.torpedoHandler(tgt);
                            return true;
                        }
                    )
                );
            }
            else
            {
                this.options.push
                (
                    new MenuOption
                    (
                        x + 1,
                        ") ",
                        "???????#####?#??#???#??#??????????",
                        function()
                        {
                            gameOutputAppend("\nUnable to lock on to target due to short range sensor damage");
                            return true;
                        }
                    )
                );
            }
        }

        let manualString = "MANUAL TARGETING" 
        if (!trekgame.enterprise.components.PhotonTubes.targetingAvailable())
        {
            manualString += "(CHANCE TO HIT : " + (100 * trekgame.enterprise.components.PhotonTubes.torpedoAccuracy()) + "%)";
        }  
        this.options.push
        (
            new MenuOption
            (
                this.options.length + 1, 
                ") ",
                manualString,
                function()
                {
                    trekgame.manualTorpedoHandler();
                }
            )
        );

        this.options.push
        (
            new MenuOption
            (
                this.options.length + 1, 
                ") ",
                "BACK",
                function()
                {
                    console.log("back button");
                    return true;
                }
            )
        );
    }
}

// ------- PhaserMenu.js ------- 
class PhaserMenu extends Menu
{

    phaserMenuSet(base, increment, count)
    {
        let rval = new Menu();
        let trekgame = this.trekgame;

        for (var i = 1; i <= count; i++)
        {
            let energy = base + (i-1) * increment;
            rval.options.push
            (
                new MenuOption
                (
                    i, ") ", energy + " ENERGY", function()
                    {
                        trekgame.firePhasersEnergy(energy)
                        return true;
                    }
                )
            );
        }

        rval.options.push
        (
            new MenuOption
            (
                "" + (count+1), ") ", "BACK", function(){return true;}
            )
        );

        return rval;
    }

    constructor(trekgame)
    {
        super();

        this.trekgame = trekgame;
        let lowMenu  = this.phaserMenuSet(250, 50, 6);
        let medMenu  = this.phaserMenuSet(500, 100, 6);
        let highMenu = this.phaserMenuSet(1000, 500, 5);

        this.options = 
        [
            new MenuOption("1", ") ", "LOW (250-500)", 
                function()
                {
                    trekgame.showMenu(lowMenu);
                    return false;
                }),
            new MenuOption("2", ") ", "MEDIUM(500-1000)",
            function()
            {
                trekgame.showMenu(medMenu);
                return false;
            }),
            new MenuOption("3", ") ", "HIGH (1000-3000)", 
                function()
                {
                    trekgame.showMenu(highMenu);
                    return false;
                }),
            new MenuOption("4", ") ", "TYPE CUSTOM ENTRY",
                function()
                {
                    trekgame.manualPhaserEntry();
                    return false;
                }),
            new MenuOption("5", ") ", "BACK", 
                function()
                {
                    return true;
                })
        ];
    }
}

// ------- ShipComputer.js ------- 
class ShipComputerMenu extends Menu
{
    constructor(trekGame)
    {
        super();
        this.options = [];

        this.options.push(

            new MenuOption
            (
                "1",
                ") ",
                "CAPTAIN'S MANUAL",
                function()
                {
                    trekGame.printTutorial();
                    return false;
                }
            ),

            new MenuOption
            (
                "2",
                ") ",
                "DAMAGE REPORT",
                function()
                {
                    trekGame.enterprise.damageReport();
                    return true;
                }
            ),

            new MenuOption
            (
                "3", ") ", "MAPS",
                function()
                {
                    ShipComputerMenu.showMapMenu(trekGame);
                    return false;
                }
            ),

            new MenuOption
            (
                "4",
                ") ",
                "SELF DESTRUCT",
                function()
                {
                    let resignMenu = new Menu();

                    resignMenu.options.push
                    (
                        new MenuOption("1", ") ", "END CURRENT GAME AND ERASE SAVE", function(){trekGame.endGame()}),
                        new MenuOption("2", ") ", "CANCEL", function(){return true})
                    );

                    trekGame.awaitInput(resignMenu.toString(), "1", function(inputLine){return resignMenu.chooseOption(inputLine);});
                    return;
                }
            ),

            new MenuOption
            (
                "5",
                ") ",
                "BACK",
                function()
                {
                    return true;
                }
            )

        );
    }

    static showMapMenu(trekGame)
    {
        let mapMenu = new Menu();

        mapMenu.options.push(
        new MenuOption
            (
                "1",
                ") ",
                "STARBASE MAP",
                function()
                {
                    if (!trekGame.enterprise.components.LibraryComputer.mapsAccessible())
                    {
                        gameOutputAppend("\nShip's computer too damaged to access maps.");
                        return true;
                    }

                    gameOutputAppend(trekgame.primeUniverse ? "\nFEDERATION STARBASES" : "\nIMPERIAL STARBASES");
                    gameOutputAppend(trekGame.galaxyMap.mapString(trekGame.galaxyMap, StarBase, trekGame.enterprise));
                    return true;
                }
            ),

            new MenuOption
            (
                "2",
                ") ",
                trekGame.primeUniverse ? "KLINGONS MAP" : "ENEMY LOCATIONS MAP",
                function()
                {
                    if (!trekGame.enterprise.components.LibraryComputer.mapsAccessible())
                    {
                        gameOutputAppend("\nShip's computer too damaged to access maps.");
                        return true;
                    }

                    gameOutputAppend("\nSENSOR RECORDS OF ENEMIES IN EACH SECTOR");
                    gameOutputAppend(trekGame.enterprise.sensorHistory.mapString(Klingon, trekGame.enterprise));
                    return true;
                }
            ),

            new MenuOption
            (
                "3",
                ") ",
                "STAR DENSITY MAP",
                function()
                {
                    if (!trekGame.enterprise.components.LibraryComputer.mapsAccessible())
                    {
                        gameOutputAppend("\nShip's computer too damaged to access maps.");
                        return true;
                    }
                    
                    gameOutputAppend("\nSENSOR RECORDS SHOWING NUMBER OF STARS IN EACH SECTOR");
                    gameOutputAppend(trekGame.enterprise.sensorHistory.mapString(Star, trekGame.enterprise));
                    return true;
                }
            ), 

            new MenuOption("4", ") ", "BACK", function(){return true;})
        );

        trekGame.awaitInput(mapMenu.toString(), "1", function(inputLine){return mapMenu.chooseOption(inputLine);});
    }
}

// ------- TrekGame.js ------- 
class TrekGame
{
    static ConstructFromJSData(jsData)
    {
        try
        {
            let gamerval = Object.create(TrekGame.prototype);
            Object.assign(gamerval, jsData);

            gamerval.enterprise = Enterprise.ConstructFromJSData(jsData.enterprise);

            gamerval.galaxyMap = GalaxyMap.ConstructFromJSData(jsData.galaxyMap);

            // console.log("galaxy map : " + gamerval.galaxyMap);

            gamerval.currentQuadrant = gamerval.galaxyMap.lookup(gamerval.enterprise.quadrantX, gamerval.enterprise.quadrantY);

            gamerval.currentQuadrant.addEntity(gamerval.enterprise);

            gamerval.applySettings();

            gamerval.createMenus();

            gamerval.mapScreenGalaxy = false;

            gamerval.checkStarbaseDock();
            gamerval.checkPlanetBombard();

            if (gamerval.enterprise.dockStarbase)
            {
                gamerval.showDockMenu();
            }
            else
            {
                gamerval.setInputPrompt(gamerval.mainMenu.toString());
            }

            gamerval.updateDisplay();
            return gamerval;
        }
        catch(err)
        {
            console.log(err);
            console.log("Corrupt save file.  Erasing.");
            autosave(null);
            gameOutputAppend("Corrupt save file.  Refresh page to start new game.");
        }
    }

    parseGameSettings(gameSettings)
    {
        // default before parse
        this.primeUniverse = false;
        this.typingFree = false;

        this.primeUniverse = gameSettings["PrimeUniverse"] == 'true';
        this.typingFree = gameSettings["TypingFree"] == 'true';

        console.log("typing free : " + this.typingFree);
        console.log("prime universe : " + this.primeUniverse);
    }

    applySettings()
    {
        Menu.TypingFree = this.typingFree;
        Grid.TypingFree = this.typingFree;

        if (this.primeUniverse)
        {
            Planet.MaxInstances = 0;
            Planet.MinInstances = 0;
            Klingon.stringRepresentation = "+K+";
        }
        else
        {
            Klingon.stringRepresentation = "+F+";
        }

        if (this.typingFree)
        {
            this.disableInputKeepPrompt();
        }
    }

    constructor(gameSettings)
    {
        this.parseGameSettings(gameSettings);
        this.applySettings();

        this.gameOver = false;
        this.mapScreenGalaxy = false;

        this.galaxyMap = new GalaxyMap(mapWidthQuadrants, mapHeightQuadrants, TrekGame.EntityTypes);
        
        this.enterprise = new Enterprise();

        // start in a random quadrant
        this.enterprise.quadrantX = randomInt(0, mapWidthQuadrants - 1);
        this.enterprise.quadrantY = randomInt(0, mapHeightQuadrants - 1);
        this.enterprise.sectorX = 0;
        this.enterprise.sectorY = 0;
        
        this.currentQuadrant = this.galaxyMap.lookup(this.enterprise.quadrantX, this.enterprise.quadrantY);

        this.currentQuadrant.addEntityInFreeSector(this.enterprise);

        // pick a stardate between the start and end of TOS
        this.starDate = randomInt(1312, 5928);
        this.starDateBegin = this.starDate;
        this.endStarDate = this.starDate + TrekGame.BaseMissionTime + randomInt(0, TrekGame.MissionTimeSpread);

        this.currentQuadrantScanned = false;

        this.createMenus();
        this.setInputPrompt(this.mainMenu.toString());

        this.updateGame();

        this.printStory();

        autosave(this);
    }

    showDockMenu(sb)
    {
        let dockMenu = new Menu();
        let trekgame = this;

        dockMenu.options.push
        (
            new MenuOption
            (
                "1",
                ") ", 
                "STAY DOCKED (1 STARDATE, REPAIRS A COMPONENT)",
                function()
                {
                    trekgame.advanceStardate(1.0);
                    trekgame.enterprise.repairRandomComponent();
                    return false;
                }
            ),
            new MenuOption
            (
                "2",
                ") ",
                "UNDOCK",
                function()
                {
                    trekgame.enterprise.undock(sb);
                    gameOutputAppend("Undocking from starbase");

                    // explicitly doesn't take a stardate to do this action.

                    return true;
                }
            ),
            new MenuOption
            (
                "3", ") ", "DAMAGE REPORT", 
                function()
                {
                    trekgame.enterprise.damageReport();
                    return false;
                }
            ),
        );

        this.awaitInput
        (
            dockMenu.toString(),
            1,
            function(inputline){return dockMenu.chooseOption(inputline);}
        );
    }

    starbasesScan()
    {
        var sh = this.enterprise.sensorHistory;

        for (var x in StarBase.starbaseList)
        {
            let starbase = StarBase.starbaseList[x];
            sh.updateSensorHistoryForEntityTypes
            (
                [Star, Klingon], 
                this.galaxyMap, 
                starbase.quadrantX-1, 
                starbase.quadrantY-1, 
                starbase.quadrantX+1, 
                starbase.quadrantY+1
            );
        }
    }
    
    generateScore(gameWon)
    {
        let baseScore = 1000 * (Klingon.InstancesDestroyed / (1 + this.starDate - this.starDateBegin));
        let winMultiplier = 2.0;

        return gameWon ? Math.round(winMultiplier * baseScore) : Math.round(baseScore);
    }

    destroyKlingon(k)
    {
        gameOutputAppend(this.primeUniverse ? "Klingon Fighter Destroyed" : "Enemy vessel destroyed.");
        this.currentQuadrant.removeEntity(k);
        Klingon.Instances--;
        Klingon.InstancesDestroyed++;
    }

    printStory()
    {
        if (this.primeUniverse)
        {
            var storyString = "The stardate is " + this.starDate + ".\n\nYou are the captain of the USS Enterprise.  " +
            "You have received word from Starfleet command of a plot by Klingon spies to destroy all the Federation " +
            "starbases in the region so the Klingon Empire can assume control.\n\n";

            storyString += 
            "The Federation is in danger and you are the only ship in range.\n\n"

            storyString+= 
            "Your mission is to hunt down and destroy the " + Klingon.Instances + " Klingon warships in the region.\n" + 
            "You must complete your mission before stardate " + this.endStarDate + ", giving you " + (this.endStarDate - this.starDate) + 
            " stardates to succeed.";

            storyString += 
            "\n\nThere are " + StarBase.Instances + " Federation Starbases in the region for refueling, restocking torpedoes, and repairs.";

            storyString += "\n\nCheck the ship's computer to access the captain's manual for a tutorial on how to complete your mission.";

            storyString += "\n\nGood luck, galactic peace is in your hands!";
            gameOutputAppend(storyString);
        }
        else
        {
            var storyString = "";

            storyString += "The stardate is " + this.starDate + ".\n\nYou are the captain of the ISS Enterprise.  " +
            "You have received word from Starfleet command of a plot by spies from a faction called the \"Federation\" to hack our starbases to spread " +
            "propaganda encouraging people to rebel against the Terran Empire. The Empire's external enemies want to use internal strife to make it easier to conquer and enslave.";
            storyString += "\n\nThis must be prevented at any cost.  ";

            storyString+= 
            "\n\nYour mission is to hunt down and destroy the " + Klingon.Instances + " Federation ships in the region.\n" + 
            "You must complete your mission before stardate " + this.endStarDate + ", giving you " + (this.endStarDate - this.starDate) + 
            " stardates to succeed.";

            storyString += 
            "\n\nThere are " + StarBase.Instances + " Imperial Starbases in the region for refueling, restocking torpedoes, and repairs.";

            storyString += "\n\nIf you fail, the consequences to yourself will be severe.  Terror must be maintained or the Empire is doomed.";

            storyString += "\n\nCheck the ship's computer to access the captain's manual for a tutorial on how to complete your mission.";

            gameOutputAppend(storyString);
        }

        let enemyCount = this.currentQuadrant.countEntitiesOfType(Klingon);
        if (enemyCount)
        {
            gameOutputAppend("\n=============================\n");
            gameOutputAppend("As you begin your mission, you find yourself in a sector with " + (enemyCount > 1) ?  " enemy ships." : " an enemy ship.");
            gameOutputAppend("Prepare for combat!");
        }
        else
        {
            gameOutputAppend("\n=============================\n");
            gameOutputAppend("As you begin your mission, you find yourself in a sector clear of enemy ships.  You will have to use navigation to jump to another sector to engage with the enemy.");
            gameOutputAppend("If the sectors adjacent to your ship are unexplored, you can use your long range sensors to try and find the enemy.");
        }

    }

    printTutorial()
    {
        let tutorialMenu = new Menu();

        let trekGame = this;

        tutorialMenu.options.push
        (
            new MenuOption
            (
                "1", ") ", "TUTORIAL: MAIN DISPLAY",
                function()
                {
                    let tutorialString = "";

                    tutorialString += "DISPLAY:\nThe map display at the top of your screen shows the map of the galactic sector where your ship is located.  ";
                    tutorialString += "Your mission takes place in a region of the galaxy that is " + mapWidthQuadrants + " by " + mapHeightQuadrants + " sectors.";
                    tutorialString += "  A galactic sector is about 2 light years across.";

                    tutorialString += "\n\nThe sector map is made up of a grid of subsectors.  The X,Y coordinates of the subsectors are displayed across the horizontal and vertical axes of the map.  The key symbols corresponding to different objects occupying a subsector are listed below.";

                    tutorialString += "\n\nTo the right of the map screen are important stats about your mission, your ship's status, and your ship's location. ";

                    tutorialString += "\n\nBelow the map screen are important status flags, such as whether the shields are too low or whether we're at red alert when enemies are present. ";

                    tutorialString += "\n\nMap key :\n";

                    tutorialString += this.primeUniverse ? 
                    "<*> : ENTERPRISE\n*  : STAR\n+K+ : KLINGON\n>!< : STARBASE\n"
                    :
                    "<*> : ENTERPRISE\n*  : STAR\n+F+ : FEDERATION SHIP\n>!< : STARBASE\n";

                    gameOutputAppend(tutorialString);

                    trekGame.printTutorial();
                    return false;
                }
            ),

            new MenuOption("2", ") ", "TUTORIAL: SHIELDS AND TAKING DAMAGE",
                function()
                {
                    let tutorialString = "";

                    tutorialString += "\n\nSHIELDS:\nShield control will let you set the amount of the ship's energy you are committing to shields.  When shields are raised, they will absorb damage.";
                    tutorialString += "\n\nShield control (if sufficiently undamaged) will suggest a minimum shield level for the current combat situation.";
                    tutorialString += "\n\nYou can also reduce the damage you take by getting further from the enemy vessel.";
                    tutorialString += "\n\nDAMAGE:\nIf you take a hit from enemy phaser fire with no shields up, you will be destroyed.  As you take hits, various components of your ship ";
                    tutorialString += "may also degrade.  Each stardate, your repair teams will restore some small percentage of that component's integrity.  ";
                    tutorialString += "When a component's integrity gets low enough, you may see functionality impaired.  Check the damage report in the ship's computer ";
                    tutorialString += "to see both the current integrity of all your individual components as well as a list of any malfunctions.  \n\nYou can also get repairs at a starbase.";

                    gameOutputAppend(tutorialString);

                    trekGame.printTutorial();
                    return false;
                }
            ),

            new MenuOption("3", ") ", "TUTORIAL: STARBASES",
                function()
                {
                    let tutorialString = "";

                    tutorialString += "\n\STARBASES:\nDocking at a starbase will restore your energy and torpedoes to maximum and repair a random ship component to full integrity.  ";
                    tutorialString += "Each additional date docked at the starbase will fully repair an additional random component.  The starbase's shields will protect you from enemy fire so long as you are docked.";

                    tutorialString += "\n\nTo dock at a starbase, use a short range jump to navigate to a subsector adjacent to the starbase.  Then the option to dock will appear on the menu.\n\nA map of all the sectors containing starbases can be found in the ship's computer.";
                   
                    gameOutputAppend(tutorialString);

                    trekGame.printTutorial();
                    return false;
                }
            ),

            new MenuOption("4", ") ", "TUTORIAL: NAVIGATION",
                function()
                {
                    let tutorialString = "";

                    tutorialString += "\n\nNAVIGATION:\nA short range jump lets you warp to a different subsector in the current sector (eg. a different location on the current map screen). ";
                    tutorialString += "\nA long range jump lets you warp to a different sector in the galaxy (eg. change to a different map screen). ";
                    tutorialString += "\n\nA short range jump needs a clear path to the target subsector or you will exit warp.  A long range jump will take you to a random subsector of your destination sector, and will ignore any obstacles along the way.";
                    tutorialString += "\n\nBoth a short range and long range jump require more energy the further you attempt to travel.";
                    tutorialString += "\n\nIf you are in a sector with enemies, make sure you raise your shields before making a short range jump.";
            
                    gameOutputAppend(tutorialString);

                    trekGame.printTutorial();
                    return false;
                }
            ),


            new MenuOption("5", ") ", "TUTORIAL: MAPS AND SENSORS",
                function()
                {
                    let tutorialString = "";

                    tutorialString += "\n\MAPS:\n";
                    tutorialString += "Galaxy maps can be found in the ship's computer.\n\nThe starbase map shows the sectors that contain a starbase.  The locations of all starbases are known at the beginning of your mission.";
                    
                    if (this.primeUniverse)
                    {
                        tutorialString += "\n\nThe klingons map shows the number of enemies in each sector based on your previous long range scans.  Starbases also do a continous long range scan and update your map.  Uncharted sectors display a question mark.";
                    }
                    else
                    {
                        tutorialString += "\n\nThe enemy locations map shows the number of enemies in each sector based on your previous long range scans.  Starbases also do a continous long range scan and update your map.  Uncharted sectors display a question mark.";
                    }
                    tutorialString += "\n\nThe star density map shows the number of stars in each sector based on your previous long range scans.  Starbases also do a continous long range scan and update your map.  Uncharted sectors display a question mark.";
                    tutorialString += "\nThe galaxy maps in the ship computer show an E in the sector corresponding to the location of your ship.";

                    tutorialString += "\n\nSENSORS:";
                    tutorialString += "\nLong range sensors scan the 3x3 region of sectors surrounding your ship for stars and enemies, then updates the maps in the library computer.";                    
                    tutorialString += "\n\nCombat sensors will tell you the shield level of enemies in the sector, and the estimated phaser energy needed to destroy them.";
                    tutorialString += "\nYou only need to pay the energy cost of the scan once, until you leave the sector.  The ship's computer will automatically update the values as combat unfolds.\nYou can consult the scan anytime for up to date values."
            
                    gameOutputAppend(tutorialString);

                    trekGame.printTutorial();
                    return false;
                }
            ),

            new MenuOption("6", ") ", "TUTORIAL: WEAPONS",
                function()
                {
                    let tutorialString = "";

                    tutorialString += "\n\WEAPONS:\nTorpedoes will instantly destroy a single enemy vessel on impact.  ";
                    tutorialString += "They cannot pass through stars or other obstructions though, and you have a limited supply (that can be replenished at a starbase).  ";
                    tutorialString += "You should use a short range jump to navigate to a location with a clear shot.  \n\nThe targeting computer will list ";
                    tutorialString += "all the targets in the sector for you to choose from.  If the targeting computer is damaged, you may need to target the torpedoes manually.";
                    tutorialString += "\n\nPhasers ignore obstructions and target all targets in the sector at the same time.  To fire phasers you must commit some portion of your free energy to the phaser blast.\n\n";
                    tutorialString += "The more targets in the sector and the further away you are from them, the more energy you will need to commit to do the same amount of damage.";
            
                    gameOutputAppend(tutorialString);

                    trekGame.printTutorial();
                    return false;
                }
            ),

            new MenuOption("7", ") ", "BACK",
                function()
                {
                    return true;
                }
            )
        );

        this.awaitInput(tutorialMenu.toString(), 1, function(inputline){return tutorialMenu.chooseOption(inputline);});
        return false;
    }

    changeToQuadrant(qX, qY)
    {
        this.currentQuadrantScanned = false;

        this.currentQuadrant.removeEntity(this.enterprise);
        this.currentQuadrant = this.galaxyMap.lookup(qX, qY);
        this.currentQuadrant.addEntityInFreeSector(this.enterprise);

        gameOutputAppend("\nEntering galactic sector " + this.enterprise.quadrantString());
    }

    statusString()
    {
        return "<pre>" +
        "\n\n\n" + 
        "STARDATES REMAINING   " + (this.endStarDate - this.starDate) +"\n" +
        "SECTOR (X,Y)          " + (this.enterprise.quadrantX+1) +  ',' + (this.enterprise.quadrantY+1) + '\n' + 
        "SUBSECTOR (X,Y)       " + (this.enterprise.sectorX+1) +  ',' + (this.enterprise.sectorY+1) + "\n" + 
        "PHOTON TORPEDOES      " + this.enterprise.torpedoes + '\n' + 
        "SHIELD ENERGY         " + this.enterprise.shields + '\n' + 
        "FREE ENERGY           " + this.enterprise.freeEnergy + '\n' + 
        (this.primeUniverse ? "KLINGONS REMAINING    " : "TRAITORS REMAINING    ")
        + Klingon.Instances + '\n' + 
        "STARBASES REMAINING   " + StarBase.Instances + '\n' +
        "</pre>";
    }

    setInputPrompt(newprompt)
    {
        document.getElementById("inputPrompt").innerHTML = newprompt;
    }

    bombardPlanet()
    {
        let adjacentPlanets = this.currentQuadrant.getAdjacentEntitiesOfType(this.enterprise, Planet);
        console.assert(adjacentPlanets.length);

        let p = adjacentPlanets[0];

        if (this.enterprise.bombardPlanet(this, p))
        {
            this.advanceStardate(1.0);
        }
    }

    shieldHandler(inputline)
    {
        let parsedVal = parseInt(inputline);

        if (isNaN(parsedVal) || parsedVal < 0)
        {
            gameOutputAppend("Invalid value!");
            return false;
        }
        if (parsedVal > (this.enterprise.shields + this.enterprise.freeEnergy))
        {
            gameOutputAppend("We don't have enough energy for that, captain!");
            return false;
        }
        
        //gameOutputAppend(""+parsedVal);

        this.enterprise.setShieldLevel(parsedVal);

        this.combatStep();

        return true;
    }


    // finalHandler has prototype (game, x, y)
    getSubsectorMenu(finalHandler)
    {
        let promptstringX = "Enter destination subsector X coordinate.  Enter a value between 1 and " + quadrantWidthSectors;
        let promptstringY = "Enter destination subsector Y coordinate.  Enter a value between 1 and " + quadrantHeightSectors;

        let trekgame = this;

        let yhandler = function(inputline, subsectorX)
        {
            let subsectorY = parseInt(inputline) - 1;

            if ((subsectorY == null) || isNaN(subsectorY) || subsectorY < 0 || subsectorY >= quadrantHeightSectors)
            {
                gameOutputAppend("Invalid value!");
                return false;
            }

            return finalHandler(game, subsectorX, subsectorY);
        };

        let xhandler = function(inputline)
        {
            let subsectorX = parseInt(inputline) - 1;

            if ((subsectorX == null) || isNaN(subsectorX) || subsectorX < 0 || subsectorX >= quadrantWidthSectors)
            {
                gameOutputAppend("Invalid value!");
                return false;
            }

            this.awaitInput
            (
                promptstringY,
                2, 
                function(inputline)
                {
                    return yhandler(inputline, subsectorX)
                }
            );
            
            return false;
        }

        this.awaitInput(
            promptstringX,
            2,
            xhandler
        );

    }

    navigationHandlerLongRangeX(inputline)
    {
        console.log("nav");
        let quadrantX = parseInt(inputline) - 1;

        if ((quadrantX == null) || isNaN(quadrantX) || quadrantX < 0 || quadrantX >= mapWidthQuadrants)
        {
            gameOutputAppend("Invalid value!");
            return false;
        }

        this.awaitInput(
            "Enter destination sector Y coordinate.  Enter a value between 1 and " + mapHeightQuadrants,
            2, 
            
            function(inputline)
            {
                return this.navigationHandlerLongRangeY(inputline, quadrantX);
            }
        );
        
        return false;
    }

    navigationHandlerLongRangeY(inputline, quadrantX)
    {
        let quadrantY = parseInt(inputline) - 1;

        if ((quadrantY == null) || isNaN(quadrantY) || quadrantY < 0 || quadrantY >= mapHeightQuadrants)
        {
            gameOutputAppend("Invalid value!");
            return false;
        }

        this.longRangeJump(quadrantX, quadrantY);
    }

    manualPhaserEntry()
    {
        let freestring = "\nFREE ENERGY : " + this.enterprise.freeEnergy;
                        
        let accuracy = this.enterprise.components.PhaserControl.phaserAccuracy() * 100;
        let chanceToHitString = "PHASER CHANCE TO HIT : " + accuracy + "%";
        
        this.awaitInput(chanceToHitString + "\nENTER ENERGY TO EXPEND ON PHASER FIRE"+freestring, 4, this.phaserHandler, true);

        return false;
    }

    longRangeJump(quadrantX, quadrantY)
    {
        let xd = quadrantX - this.enterprise.quadrantX;
        let yd = quadrantY - this.enterprise.quadrantY;
        let travelDistance = Math.sqrt(xd*xd + yd*yd);  // assumes single stardate.  so distance and speed have the same scalar value.

        let maxSpeed = this.enterprise.components.WarpEngines.maxSpeed();

        if (!this.enterprise.components.WarpEngines.fullyFunctional() && (travelDistance > maxSpeed))
        {
            xd /= travelDistance;
            yd /= travelDistance;

            xd *= maxSpeed;
            yd *= maxSpeed;
            
            travelDistance = Math.sqrt(xd*xd + yd*yd);

            quadrantX = Math.floor(this.enterprise.quadrantX + xd);
            quadrantY = Math.floor(this.enterprise.quadrantY + yd);

            gameOutputAppend("Unable to make it to the destination warp target in a single jump due to damage.  New destination is Sector " + (quadrantX+1) + ", " + (quadrantY+1));
        }

        let jumpEnergyRequired = Math.floor(Enterprise.EnergyCostPerQuadrant * travelDistance);

        if (this.enterprise.freeEnergy < jumpEnergyRequired)
        {
            gameOutputAppend("Insufficient energy for long range jump, captain.  Jump requires " + jumpEnergyRequired + " free energy.");
            return true;
        }

        let sensorHistory = this.enterprise.sensorHistory.lookup(quadrantX, quadrantY);
        
        if (Klingon in sensorHistory)
        {
            gameOutputAppend("\nThe destination sector " + "(" + (1+quadrantX) + ',' + (1+quadrantY) +  ")" + " contains the following: ");

            if (sensorHistory[Klingon] > 0)
            {
                gameOutputAppend( (this.primeUniverse ? "Klingons : " : "Enemy vessels") + sensorHistory[Klingon]);
            }

            if (this.galaxyMap.lookup(quadrantX, quadrantY).countEntitiesOfType(StarBase) > 0)
            {
                gameOutputAppend("Starbases : 1");
            }

            if (sensorHistory[Star] > 0)
            {
                gameOutputAppend("Stars : " + sensorHistory[Star]);
            }
        }
        else
        {
            gameOutputAppend("\nThe destination sector " + "(" + (1+quadrantX) + ',' + (1+quadrantY) +  ")" + " is unexplored.");
        }

        let trekgame = this;
        let confirmMenu = new Menu();
        confirmMenu.options.push
        (
            new MenuOption
            (
                "1", 
                ") ", 
                "CONFIRM JUMP TO SECTOR " + (quadrantX+1) + ", " + (quadrantY+1) + ".\nTRIP TAKES 1 STARDATE, " + jumpEnergyRequired + " ENERGY\n",
                function()
                {
                    trekgame.mapScreenGalaxy = false;
                    trekgame.gridHandler = null;

                    trekgame.enterprise.freeEnergy -= jumpEnergyRequired;
                    trekgame.changeToQuadrant(quadrantX, quadrantY);
                    trekgame.advanceStardateNoCombat(1.0); // don't get blown up as soon as we enter a new Sector!
                    return true;
                }
            ),

            new MenuOption
            (
                "2",
                ") ",
                "CANCEL",
                function()
                {
                    trekgame.gridHandler = null;
                    trekgame.mapScreenGalaxy = false;
                    return true;
                }
            )
        );

        this.awaitInput(confirmMenu.toString(), 1, function(inputline){return confirmMenu.chooseOption(inputline);});
        return false;
    }

    shortRangeNavigationHandler(trekgame, subsectorX, subsectorY)
    {
        let sectorsToTravel = trekgame.enterprise.distanceToSectorLoc(subsectorX, subsectorY);

        let confirmFunc = function()
        {
            if (trekgame.enterprise.warp(subsectorX, subsectorY, sectorsToTravel, trekgame))
            {
                gameOutputAppend("\nComing out of warp in sector " + trekgame.enterprise.sectorString());
                trekgame.advanceStardate(1.0);
            }

            trekgame.gridHandler = null;

            return true;
        }

        let jumpEnergyRequired = Math.round(trekgame.enterprise.warpEnergyCost(sectorsToTravel));

        let confirmMenu = new Menu();
        confirmMenu.options.push
        (
            new MenuOption
            (
                "1", 
                ") ", 
                "CONFIRM JUMP TO SUBSECTOR " + (subsectorX+1) + ", " + (subsectorY+1) + ".\nTRIP TAKES 1 STARDATE, " + jumpEnergyRequired + " ENERGY\n",
                confirmFunc
            ),

            new MenuOption
            (
                "2",
                ") ",
                "CANCEL",
                function()
                {
                    return true;
                }
            )
        )
        
        trekgame.awaitInput(confirmMenu.toString(), 1, function(inputline){return confirmMenu.chooseOption(inputline);});
        return false;
    }

    scanEnemyShips()
    {
        if (this.enterprise.freeEnergy < Enterprise.EnemyScanCost)
        {
            gameOutputAppend("\nNot enough energy to scan the enemy ships, captain!");
            return;
        }

        let enemylist = this.currentQuadrant.getEntitiesOfType(Klingon);

        if (!enemylist.length)
        {
            gameOutputAppend("\nNo enemies in this sector to scan, captain!");
            return;
        }

        this.enterprise.freeEnergy -= Enterprise.EnemyScanCost;
        this.currentQuadrantScanned = true;

        gameOutputAppend("\nENEMY SHIP SCANNER REPORTS");

        let e_max_of_min = 0;
        let e_max_of_max = 0;

        let allEnemiesVisible = true;

        for (var x in enemylist)
        {
            let k = enemylist[x];

            // invert the enterprise phaser equations to get the estimate 
            ///\todo make this a subfunction of Enterprise...

            let kshields = k.shields;
            let dist_to_k = this.enterprise.distanceToObject(k);

            let minRandom = 2.0;
            let maxRandom = 3.0;

            let e_required_max = dist_to_k * kshields / minRandom;
            let e_required_min = dist_to_k * kshields / maxRandom;

            e_max_of_min = Math.max(e_required_min, e_max_of_min);
            e_max_of_max = Math.max(e_required_max, e_max_of_max);
            
            let entityVisible = this.enterprise.canSeeEntity(k);
            if (!entityVisible)
            {
                allEnemiesVisible = false;
                gameOutputAppend("\n---SENSOR CORRUPTION DETECTED!---");
                gameOutputAppend("Enemy in subsector : ???");
                gameOutputAppend("Enemy shield level : ????");
                gameOutputAppend("Phaser energy to destroy : ??????");
            }
            else
            {
                gameOutputAppend("\nEnemy in subsector (" + k.sectorString() + ")");
                gameOutputAppend("Enemy shield level : " + kshields);
                gameOutputAppend("Phaser energy to destroy : " + Math.round(e_required_min) + "-" + Math.round(e_required_max));
            }
        }

        gameOutputAppend("\nTotal enemies : " + enemylist.length);
        
        if (allEnemiesVisible)
        {
            gameOutputAppend("Total energy to destroy : " + Math.round(enemylist.length * e_max_of_min) + "-" + Math.round(enemylist.length * e_max_of_max));
        }
        else
        {
            gameOutputAppend("Total energy to destroy : ?????");
        }
        gameOutputAppend("\n");
    }

    longRangeScan()
    {
        if (!this.enterprise.components.LongRangeSensors.functional())
        {
            gameOutputAppend("\nLong range scan unavailable due to damage.");
            return;
        }

        gameOutputAppend("\nLong Range Scan completed.");
        gameOutputAppend("Adjacent sectors have been scanned.  The ship's computer has been updated with the following information:\n");
        gameOutputAppend(this.enterprise.lrsString(this, this.galaxyMap));

        var sh = this.enterprise.sensorHistory;
        sh.updateSensorHistoryForEntityTypes
        (
            [Star, Klingon], 
            this.galaxyMap, 
            this.enterprise.quadrantX-1, 
            this.enterprise.quadrantY-1, 
            this.enterprise.quadrantX+1, 
            this.enterprise.quadrantY+1
        );

        this.advanceStardate(1.0);
    }

    manualTorpedoHandler()
    {
        let tfunc = function(trekgame, x, y){
            let gobj = new GameObject();
            gobj.sectorX = x;
            gobj.sectorY = y;
            trekgame.torpedoHandler(gobj)
            return true;
        };

        if (!this.typingFree)
        {
            this.getSubsectorMenu(tfunc);
        }
        else
        {
            let trekgame = this;
            this.gridHandler = function(x,y)
            {
                tfunc(trekgame,x,y);
                trekgame.gridHandler = null;
                trekgame.updateDisplay();
                trekgame.awaitInput(trekgame.mainMenu.toString());
            };

            this.showBackMenu("SELECT TORPEDO DESTINATION ON THE MAP");
        }
    }

    showBackMenu(headerString)
    {
        let backMenu = new Menu();
        let trekgame = this;

        backMenu.headerString = headerString;
        backMenu.options.push
        (
            new MenuOption
            (
                "1",
                ") ",
                "BACK",
                function()
                {
                    trekgame.gridHandler = null;
                    trekgame.mapScreenGalaxy = false;
                    return true;
                }
            )
        );

        this.showMenu(backMenu);
    }

    showMenu(menu)
    {
        this.awaitInput(menu.toString(), 1, function(inputline){return menu.chooseOption(inputline)});
    }

    torpedoHandler(target)
    {
        this.enterprise.fireTorpedo(this, target);

        this.combatStep();

        return true;
    }

    phaserHandler(inputline)
    {
        let energy = parseInt(inputline);

        if ((energy == null) || isNaN(energy) || energy < 0)
        {
            gameOutputAppend("Invalid value!");
            return false;
        }

        this.firePhasersEnergy(energy);

        return true;
    }

    firePhasersEnergy(energy)
    {
        if (energy > this.enterprise.freeEnergy)
        {
            gameOutputAppend("Not enough energy, captain!");
            return false;
        }

        if (energy == 0)
        {
            return true;
        }

        if (this.enterprise.firePhasers(energy, this))
        {
            this.combatStep();
        }
    }

    combatStep()
    {
        this.currentQuadrant.klingonsFire(this.enterprise, this);
        this.enterprise.components.ShortRangeSensors.generateCorruptGrid();
    }

    updateStatus()
    {
        document.getElementById("status").innerHTML = this.statusString();
        document.getElementById("status").style.display = "inline-block";
    }

    hideStatus()
    {
        document.getElementById("status").style.display = "None";
    }

    awaitInput(inputPrompt, charactersToRead=3, inputHandler=null, override=false)
    {
        document.getElementById("inputPrompt").style.display="Block";
        
        if (!this.typingFree || override)
        {
            document.getElementById("gameInput").style.display="Block";
            document.getElementById("inputButton").style.display ="Block";
        }
        else
        {
            document.getElementById("gameInput").style.display="None";
            document.getElementById("inputButton").style.display ="None";
        }

        this.inputHandler = inputHandler;
        document.getElementById("gameInput").maxLength = charactersToRead;
        this.setInputPrompt(inputPrompt);
    }

    disableInput()
    {
        document.getElementById("inputPrompt").style.display="None";
        document.getElementById("gameInput").style.display="None";
        document.getElementById("inputButton").style.display ="None";
    }

    disableInputKeepPrompt()
    {
        document.getElementById("gameInput").style.display="None";
        document.getElementById("inputButton").style.display ="None";
    }

    handleInput(inputStr)
    {
        if (this.inputHandler)
        {
            if (this.inputHandler(inputStr))
            {
                this.awaitInput(this.mainMenu.toString(), 3, null);
            }
        }
        else
        {
            this.mainMenu.chooseOption(inputStr);
        }
    }

    gameInput(inputStr)
    {
        //console.log(">"+inputStr+"\n");
        //gameOutputAppend(inputStr);

        this.handleInput(inputStr);

        this.updateGame();
        autosave(this);
    }

    updateDisplay()
    {

        if (this.mapScreenGalaxy)
        {
            this.hideStatus();
            updateMap(this.updateMapScreenGalaxy());
            updateMapHeader("GALAXY MAP : CHOOSE DESTINATION SECTOR");
            //updateMap(this.updateMapScreenGalaxy());
            
            if (this.primeUniverse)
            {
                updateMapFooter("E: ENTERPRISE | K : KLINGONS | S : STARBASE | ? : UNEXPLORED");
            }
            else
            {
                updateMapFooter("E: ENTERPRISE | F : FEDERATION SPIES | S : STARBASE | ? : UNEXPLORED");
            }
        }
        else
        {
            this.updateStatus();
            updateMap(this.updateMapScreen());
            updateMapHeader("SECTOR : " + this.enterprise.quadrantString());
            updateMapFooter(this.updateStatusFlags());
        }
    }

    checkStarbaseDock()
    {
        if (this.enterprise.dockStarbase)
        {
            console.log("already docked.");
            return;
        }

        this.mainMenu.dockOption.enabled = false;

        let starbases = this.currentQuadrant.getEntitiesOfType(StarBase);

        for (var x in starbases)
        {
            var sb = starbases[x];

            if (this.enterprise.isAdjacentTo(sb))
            {
                console.log("adjacent");
                this.mainMenu.dockOption.enabled = true;
            }
            else
            {
                console.log("not adjacent");
            }
        }

        if (!this.inputHandler)
        {
            this.awaitInput(this.mainMenu.toString(), 3, null);
        }
    }

    checkPlanetBombard()
    {
        if (this.enterprise.dockStarbase)
        {
            return;
        }

        this.mainMenu.bombardOption.enabled = false;

        let planets = this.currentQuadrant.getEntitiesOfType(Planet);

        for (var x in planets)
        {
            var p = planets[x];

            if (this.enterprise.isAdjacentTo(p) && !p.bombarded)
            {
                this.mainMenu.bombardOption.enabled = true;
            }
        }

        if (!this.inputHandler)
        {
            this.awaitInput(this.mainMenu.toString(), 3, null);
        }
    }

    updateGame()
    {
        this.updateDisplay();
        this.starbasesScan();
        this.enterpriseShortRangeScan();
        this.checkStarbaseDock();
        this.checkPlanetBombard();

        this.checkEndConditions();
    }

    enterpriseShortRangeScan()
    {
        this.enterprise.sensorHistory.updateSensorHistoryForEntityTypes
            (
                [Star, Klingon], 
                this.galaxyMap, 
                this.enterprise.quadrantX, 
                this.enterprise.quadrantY, 
                this.enterprise.quadrantX, 
                this.enterprise.quadrantY
            );
    }

    endGame()
    {
        this.gameOver = true;
        autosave(null);
        gameOutputAppend("\nThanks for playing!  Refresh the page to play again.");
        this.disableInput();
    }

    advanceStardate(adv)
    {
        this.combatStep();
        this.advanceStardateNoCombat(adv);
    }

    advanceStardateNoCombat(adv)
    {
        this.starDate += adv;
        this.enterprise.autoRepairComponents();

        let stardatesRemaining = (this.endStarDate - this.starDate);

        if (stardatesRemaining == 10)
        {
            gameOutputAppend("\nYou have 10 stardates remaining to complete your mission!");
        }
        else if (stardatesRemaining == 5)
        {
            gameOutputAppend("\nWARNING : 5 STARDATES REMAIN.");
        }
        else if (stardatesRemaining == 1)
        {
            gameOutputAppend("" + stardatesRemaining + " STARDATE LEFT!");
        }
        else if (stardatesRemaining <= 3)
        {
            gameOutputAppend("" + stardatesRemaining + " STARDATES LEFT!");
        }
    }

    checkEndConditions()
    {
        if (this.gameOver) return;

        if (this.starDate >= this.endStarDate)
        {
            gameOutputAppend("\n\n============================GAME OVER============================\n");
            
            if (this.primeUniverse)
            {
                gameOutputAppend("You were unable to complete your mission in time.");
                gameOutputAppend("The Klingons were able to execute their plan to destroy the Federation starbases!");
                gameOutputAppend("You'll be demoted for sure!");
            }
            else
            {
                gameOutputAppend("You were unable to complete your mission in time.");
                gameOutputAppend("The Federation ships were able to execute their plan.  Reports of civil unrest and insurrection start coming in from throughout the Terran Empire.");
                gameOutputAppend("\nYour second in command and his henchmen are waiting to assassinate you in your quarters.");
                gameOutputAppend("The Enterprise gets a better captain and everyone else moves up in rank.  You have paid the price for your failures.");
            }

            gameOutputAppend("\nFinal Score : " + this.generateScore(false));

            this.endGame();
        }
        else if (this.enterprise.isStranded())
        {
            gameOutputAppend("\n\n============================GAME OVER============================\n");
            gameOutputAppend("You have insufficient energy to power the warp engines!");
            gameOutputAppend("You are stranded, causing you to ultimately fail your mission.");

            gameOutputAppend("\nFinal Score : " + this.generateScore(false));
            
            this.endGame();
        }
        else if (this.enterprise.isDestroyed())
        {
            gameOutputAppend("\n\n============================GAME OVER============================\n");
            gameOutputAppend("Your vessel has taken too much damage and has been destroyed.");
            gameOutputAppend("Your mission is failed.");

            gameOutputAppend("\nFinal Score : " + this.generateScore(false));

            this.endGame();
        }
        else if (!StarBase.Instances)
        {
            gameOutputAppend("\n\n============================\GAME OVER============================\n");
            
            if (this.primeUniverse)
            {
                gameOutputAppend("All the Federation starbases have been destroyed!");
                gameOutputAppend("You've failed in your mission.  The Federation is doomed.");
            }
            else
            {
                gameOutputAppend("All the Imperial starbases have been destroyed!");
                gameOutputAppend("Insurgents from planets under the Empire's control take advantage of the power vacuum and take control of the region.");
                gameOutputAppend("The Empire has been seriously harmed by your incompetence");
                gameOutputAppend("\nYour second in command and his henchmen are waiting to assassinate you in your quarters.");
                gameOutputAppend("The Enterprise gets a better captain and everyone else moves up in rank.  You have paid the price for your failures.");
            }

            gameOutputAppend("\nFinal Score : " + this.generateScore(false));

            this.endGame();
        }
        else if (!Klingon.Instances)
        {
            gameOutputAppend("\n\n============================YOU WIN!!============================\n");
            gameOutputAppend("You've managed to destroy all the enemy vessels, preventing the enemy from executing their plan!");
            gameOutputAppend("You're sure to get a promotion!");
            
            if (this.primeUniverse)
            {
                gameOutputAppend("Congratulations on your victory!");
            }
            else
            {
                gameOutputAppend("Terror has been maintained!");
            }

            gameOutputAppend("\nFinal Score : " + this.generateScore(true));
            
            this.endGame();
        }
    }
    
    createMenus()
    {
        this.mainMenu = new MainMenu(this);
        this.computerMenu = new ShipComputerMenu(this);
    }


    updateStatusFlags()
    {
        let flags = [];
        
        if (this.enterprise.dockStarbase)
        {
            flags.push("DOCKED");
        }

        if (this.currentQuadrant.countEntitiesOfType(Klingon))
        {
            flags.push("RED ALERT");

            let estAvail = this.enterprise.components.ShieldControl.estimateAvailable();
            let critical = this.enterprise.isShieldLevelCritical(this.currentQuadrant.getEntitiesOfType(Klingon));

            if (estAvail && critical)
            {
                flags.push("SHIELDS CRITICAL");
            }
        }
        else
        {
            flags.push("SECTOR CLEAR");
        }

        return flags.join(" | ");
    }

    updateMapScreenGalaxy()
    {
        let topStr = "---------";
        let topStrLong = ' ' + topStr.repeat(mapWidthQuadrants-1);

        let rval = "<pre>" + '\n' + topStrLong + '\n';

        for (var y = 0; y < mapHeightQuadrants; y++)
        {
            rval += '|';
            for (var x = 0; x < mapWidthQuadrants; x++)
            {

                rval += "<a href=\"javascript:clickGridHandler(" + x + ","+ y +")\" style=\"color: rgb(0,255,0); text-decoration: none;\">";

                let coordstr = "("+(x+1)+","+(y+1)+")";
                rval += padStringToLength(coordstr, 7);

                rval += "</a>";

                rval += '|';
            }

            rval += '\n|';

            for (var x = 0; x < mapWidthQuadrants; x++)
            {
                rval += "<a href=\"javascript:clickGridHandler("+x+","+y+")\" style=\"color: rgb(0,255,0); text-decoration: none;\">";

                let identifiers = '';

                let sensorHistory = this.enterprise.sensorHistory.lookup(x,y);

                if (Klingon in sensorHistory)
                {
                    if ((this.enterprise.quadrantX == x) && (this.enterprise.quadrantY == y))
                    {
                        identifiers+= 'E';
                    }

                    if (sensorHistory[Klingon] > 0)
                    {
                        identifiers += this.primeUniverse ? 'K' : 'F';
                    }

                    if (this.galaxyMap.lookup(x,y).countEntitiesOfType(StarBase) > 0)
                    {
                        identifiers += 'S';
                    }
                }
                else
                {
                    identifiers += '?';
                }
                
              

                rval += padStringToLength(identifiers,7);

                rval += "</a>";

                rval += '|';
            }

            //rval += '|';

            rval += '\n' + topStrLong + '\n';
        }

        rval += "</pre>";

        return rval;
    }

    updateMapScreen()
    {
        let quad = this.currentQuadrant;

        let borderStringPost = "   " + mapFooter(quadrantWidthSectors);
        let borderStringPre = "   " + mapHeader(quadrantWidthSectors) + '\n';

        let quadrantStringGrid = new Grid(quad.width, quad.height, function(){return " ".padStart(sectorDisplayWidthChars, ' ')})

        var gameObjectIndex;
        for (gameObjectIndex in quad.quadrantEntities)
        {
            let gameObject = quad.quadrantEntities[gameObjectIndex];
            var objStr;
        
            objStr = gameObject.toString().padStart(sectorDisplayWidthChars, ' ');

            quadrantStringGrid.setValue(gameObject.sectorX, gameObject.sectorY, objStr);
        }

        if (!this.enterprise.components.ShortRangeSensors.fullyFunctional())
        {
            // randomly go through and corrupt the short range scan based on the health of the ship components
            for (var x in quadrantStringGrid.contents)
            {   
                if (this.enterprise.components.ShortRangeSensors.isSectorCorrupt1D(x))
                {
                    quadrantStringGrid.setValue1D(x, '?'.padStart(sectorDisplayWidthChars, ' '));
                }
            }
        }

        let mapString = (this.typingFree && this.gridHandler) ? quadrantStringGrid.toStringHyperlink() : quadrantStringGrid.toStringTyping();

        return "<pre>" + borderStringPre + mapString + borderStringPost + "</pre>";

    }

    clickGridHandler(x,y)
    {
        if (this.gridHandler)
        {
            this.gridHandler(x,y);
            //this.gridHandler = null;
        }
    }
}

function clickGridHandler(x,y)
{
    console.log("" + x + "," +y);
    game.clickGridHandler(x,y);
}

TrekGame.EntityTypes = [Star, StarBase, Klingon, Planet];
TrekGame.BaseMissionTime = 25;
TrekGame.MissionTimeSpread = 10;
TrekGame.BombardCost = 3;
TrekGame.BombardReinforcementSize = 5;

function createEntityMap(entityList)
{
    var map = new Map();
    var x;
    for (x in entityList)
    {
        let etype = entityList[x];
        map.set(etype.name, etype);
    }
    return map;
}

const EntityMap = createEntityMap(TrekGame.EntityTypes);

console.log("Hope you enjoy the game!");