// TrekGame.js
// Generated on Mon Jul  8 02:58:49 EDT 2019
// Making Games By Year, Episode 1
// Script generated megafile from individual .js files
// Do not edit this file, edit individual scripts in the source dir and re-run compile.sh


// ------- globals.js ------- 
const mapWidthQuadrants = 8;
const mapHeightQuadrants = 6;
const quadrantWidthSectors = 10;
const quadrantHeightSectors = 10;
const sectorDisplayWidthChars = 4;
const minKlingonsGame = 8;


// ------- util.js ------- 
function checkArgumentsDefinedAndHaveValue(args)
{
    var x;
    for (x in args)
    {
        arg = args[x];
        console.assert(!(typeof arg == "undefined" || arg == null));
    }
}

function padStringToLength(str, len, padWithChar = ' ')
{
    console.assert(str.length <= len);
    console.assert(padWithChar.length == 1);

    checkArgumentsDefinedAndHaveValue(arguments);

    let padLength = len - str.length;
    let pad1 = Math.floor(padLength / 2);
    let pad2 = padLength - pad1;
    let padLeft = Math.max(pad1,pad2);

    let leftPadStr = str.padStart(padLeft + str.length, padWithChar);

    return leftPadStr.padEnd(len, padWithChar);
}

function randomInt(min, max)
{
    checkArgumentsDefinedAndHaveValue(arguments);
    return Math.round(Math.random() * (max-min) + min);
}

function randomFloat(min, max)
{
    checkArgumentsDefinedAndHaveValue(arguments);
    return (Math.random() * (max-min) + min);
}

function gameOutputAppend(str)
{
    let textarea = document.getElementById("gameOutputBox")
    textarea.value += str + '\n';
    textarea.scrollTop = textarea.scrollHeight;
}

function updateMap(mapString = game.currentQuadrant.toString())
{
    document.getElementById("map").innerHTML = mapString;
}

function updateMapHeader(str)
{
    document.getElementById("mapHeaderQuadrant").innerHTML = "<pre>"+str+"</pre>";
}

function updateMapFooter(str)
{
    document.getElementById("statusflags").innerHTML = "<pre>"+str+"</pre>";
}

function autosave(game)
{
    //console.log("autosave func");
    //console.log(JSON.stringify(game));

    if (game && !game.gameOver)
    {
        localStorage.setItem("autosave", JSON.stringify(game));
    }
    else
    {
        localStorage.setItem("autosave", null);
    }
}

function makeCDF(instanceProbabilities)
{
    var rval = [];
    let totalSum = 0.0;

    for (var x in instanceProbabilities)
    {
        totalSum += instanceProbabilities[x];
        rval.push(totalSum);
    }

    for (var x in rval)
    {
        rval[x] /= totalSum;
    }

    // last value should always be exactly 1
    rval[rval.length-1] = 1.0;

    return rval;
}

// generates a random value, between 0 and valueProbabilities.length-1, where each possible value's chance of
// being generated is listed in the corresponding array entry
function randomWithProbabilities(valueProbabilities)
{
    let randomVal = randomFloat(0.0, 1.0);
    let cdf = makeCDF(valueProbabilities);

    //console.log("" + cdf);
    var x;
    for (x in cdf)
    {
        if (randomVal < cdf[x])
        {
            return x;
        }
    }
    return cdf.length-1;
}

function mapFooter(length)
{
    let rval = "";

    for (var x = 0; x < length; x++)
    {
        rval += "=";
        rval += padStringToLength(""+(x+1), 3, '-');
    }

    return rval;
}

function mapHeader(length)
{
    let rval = "";

    for (var x = 0; x < length; x++)
    {
        rval += "=---";
    }

    return rval;
}

// ------- Grid.js ------- 
class Grid
{
    constructor(gridX, gridY, gridItemConstructor)
    {
        checkArgumentsDefinedAndHaveValue(arguments);

        this.contents = new Array()

        this.width = gridX;
        this.height = gridY;
        this.size = gridX * gridY;

        for (let y = 0; y < this.height; y++)
        {
            for (let x = 0; x < this.width; x++)
            {
                this.contents.push(gridItemConstructor(x, y));
            }
        }
    }

    lookup(x,y)
    {
        checkArgumentsDefinedAndHaveValue(arguments);

        if (x < 0 || x >= this.width || y < 0 || y >= this.height)
        {
            return null;
        }

        return this.contents [y * this.width + x];
    }

    // 1D array based lookup
    lookup1D(x)
    {
        checkArgumentsDefinedAndHaveValue(arguments);
        return this.contents[x];
    }

    setValue(x,y,val)
    {
        checkArgumentsDefinedAndHaveValue(arguments);
        this.contents [y * this.width + x] = val;
    }

    setValue1D(x, val)
    {
        this.contents[x] = val;
    }

    getEmptySquare()
    {
        let startIndex = randomInt(0, this.contents.length-1);
        let emptyIndex = null;

        for (let i = 0; i < this.contents.length; i++)
        {
            let lookup = ( startIndex + i ) % this.contents.length;
            if (!this.contents.lookup)
            {
                emptyIndex = i;
                break;
            }
        }

        if (emptyIndex)
        {
            let rx = emptyIndex % this.width;
            let ry = emptyIndex / this.height;

            return {x : rx, y:ry};
        }
        
        return null;
    }

    toString()
    {
        let rval = "";
        for ( let y = 0; y < this.height; y++)
        {
            rval += padStringToLength(""+(y+1), 2) + '|';
            for (let x = 0; x < this.width; x++)
            {
                let catstr = this.lookup(x,y).toString();
                rval += catstr;
            }
            rval += '|';
            rval += '\n';
        }
        return rval;
    }
}

// ------- GameObject.js ------- 
class GameObject
{
    constructor(className)
    {
        this.sectorX = 0;
        this.sectorY = 0;
        this.quadrantX = 0;
        this.quadrantY = 0;
        this.entityType = this.constructor.name;

        if (!className.Instances)
        {
            className.Instances = 0;
        }

        className.Instances++;
    }

    isAdjacentTo(obj2)
    {
        let sameQuadrant = (this.quadrantX == obj2.quadrantX) && (this.quadrantY == obj2.quadrantY);
        let xSectorDiff = Math.abs(this.sectorX - obj2.sectorX);
        let ySectorDiff = Math.abs(this.sectorY - obj2.sectorY);

        console.log("quad x y " + sameQuadrant + " " + xSectorDiff + " " + ySectorDiff);

        return sameQuadrant && (xSectorDiff <= 1) && (ySectorDiff <= 1);
    }

    angleToObject(obj2)
    {
        console.log("this subsector " + this.sectorString());
        console.log("target subsector " + obj2.sectorString());

        let xdiff = obj2.sectorX - this.sectorX;
        let ydiff = obj2.sectorY - this.sectorY;

        let radians = Math.atan2(ydiff, xdiff);

        let degrees = radians * 180.0 / Math.PI;

        if (degrees < 0.0)
        {
            degrees = 360.0 + degrees;
        }

        return 360.0 - degrees;
    }

    angleToSubsector(sectorX, sectorY)
    {
        let xdiff = sectorX - this.sectorX;
        let ydiff = sectorY - this.sectorY;

        let radians = Math.atan2(ydiff, xdiff);

        let degrees = radians * 180.0 / Math.PI;

        if (degrees < 0.0)
        {
            degrees = 360.0 + degrees;
        }

        return 360.0 - degrees;
    }

    distanceToObject(obj2)
    {
        // assumes objects are in the same quadrant, for now
        let xdiff = this.sectorX - obj2.sectorX;
        let ydiff = this.sectorY - obj2.sectorY;
        return Math.sqrt(xdiff*xdiff + ydiff*ydiff);
    }

    distanceToSectorLoc(sectorX, sectorY)
    {
        let xdiff = this.sectorX - sectorX;
        let ydiff = this.sectorY - sectorY;
        return Math.sqrt(xdiff*xdiff + ydiff*ydiff);
    }

    setLocationSector(sectorXY)
    {
        this.sectorX = sectorXY.x;
        this.sectorY = sectorXY.y;
    }

    onTorpedoHit(game)
    {
        console.log("Torpedo hit (base class)");
    }

    // randomly generate the number of GameObject instances to put in a new quadrant
    static randomCountForQuadrant(quadrantFreeSpaces, instancesInQuadrant)
    {
        var rval = 0;

        let instanceProbabilities = this.quadrantInstanceProbabilities();
        if (instanceProbabilities == null)
        {
            //console.log("Using uniform probability path");
            rval = randomInt(0, this.maxInstancesQuadrant());
        }
        else
        {
            //console.log("Using CDF Probability Path");
            console.assert(instanceProbabilities.length == (1+this.maxInstancesQuadrant()));
            
            rval = randomWithProbabilities(instanceProbabilities);
        }

        rval = Math.min(rval, quadrantFreeSpaces);

        // createEntities occurs after we place our minimum number of entities around the map.
        // so if we've already created some entities in this quadrant just deduct them from the ones
        // the rng says we need to create.

        if (!this.Instances)
        {
            this.Instances = 0;
        }

        rval = Math.min(rval, this.maxInstancesGame() - this.Instances);

        console.assert(this.Instances <= this.maxInstancesGame());

        rval = Math.max(rval - instancesInQuadrant, 0);

        return rval;
    }

    sectorString()
    {
        return "" + (this.sectorX+1) + ", " + (this.sectorY+1);
    }

    quadrantString()
    {
        return "" + (this.quadrantX+1) + ", " + (this.quadrantY+1);
    }

    sectorStringFractional()
    {
        let sectorXFractional = (this.quadrantX+1) + (this.sectorX / quadrantWidthSectors);
        let sectorYFractional = (this.quadrantY+1) + (this.sectorY / quadrantHeightSectors);
        return "("+sectorXFractional+","+sectorYFractional+")";
    }

    static minInstancesGame()
    {
        return 0;
    }

    static maxInstancesQuadrant()
    {
        return 8;
    }

    static maxInstancesGame()
    {
        return this.maxInstancesQuadrant() * mapWidthQuadrants * mapHeightQuadrants;
    }

    // returns array containing the probability of each instance count appearing in a quadrant at map generation
    // eg. [.1, .2, .15, .55]
    // means that there's a 10% chance of no instances of the object in a given quadrant
    // there's a 20% chance of 1 instance
    // a 15% chance of 2 instances
    // a 55% chance of 3 instances
    // The base class GameObject method returns null, if we want to just generate uniform probabilities (default)
    // eg. each number between min and max has an equal likelihood.
    // So in the above example, there'd be a 25% chance of either no instance, 1 instance, 2 instances, or 3 instances
    static quadrantInstanceProbabilities()
    {
        return null;
    }
}

// ------- StarBase.js ------- 
class StarBase extends GameObject
{
    constructor()
    {
        super(StarBase);
        StarBase.starbaseList.push(this);
    }

    onTorpedoHit(game)
    {
        console.log("hit a starbase");
        gameOutputAppend("\nReport from sector " + this.sectorString());
        gameOutputAppend("The torpedo strikes and destroys the friendly starbase! I bet you'll be court martialled for that one!");

        game.currentQuadrant.removeEntity(this);
        StarBase.Instances--;
    }

    toString()
    {
        return ">!<";
    }

    static maxInstancesQuadrant()
    {
        return 1;
    }

    static minInstancesGame()
    {
        return 1;
    }

    static quadrantInstanceProbabilities()
    {
        // 5% chance of a starbase in any given quadrant
        return [.95, .05];
    }
}

StarBase.starbaseList = [];

// ------- Klingon.js ------- 
class Klingon extends GameObject
{
    constructor()
    {
        super(Klingon);
        this.shields = randomInt(100, 300);
    }

    onTorpedoHit(game)
    {
        console.log("hit a klingon");
        gameOutputAppend("\nReport from sector " + this.sectorString());
        
        game.destroyKlingon(this);
    }

    onPhaserHit(energy, game)
    {
        console.log("Klingon::onPhaserHit");
        let shieldDeflectionLevel = Klingon.shieldDeflectionPercent * this.shields;

        gameOutputAppend("\nReport from sector " + this.sectorString());
        if (energy <= shieldDeflectionLevel)
        {
            gameOutputAppend("Phaser hit did no damage!");
        }
        else
        {
            gameOutputAppend("Phaser hit the klingon fighter for " + energy + " damage.");

            this.shields -= energy;

            if (this.shields <= 0)
            {
                game.destroyKlingon(this);
            }
            else
            {
                gameOutputAppend("" + this.shields + " units remain.");
            }
        }
    }

    phaserDamageBase(dist)
    {
        let energyToFire = this.shields;
        return Math.round(energyToFire / dist);
    }

    firePhasers(target, game)
    {
        let dist = this.distanceToObject(target);
        let phaserDamage = this.phaserDamageBase(dist) * randomInt(Klingon.MinPhaserMultiplier, Klingon.MaxPhaserMultiplier);

        gameOutputAppend("Hit from sector " + this.sectorString() + " for " + phaserDamage + " units");
        target.onPhaserHit(phaserDamage, game);
    }

    minPhaserDamage()
    {
        return Klingon.MinPhaserMultiplier * this.phaserDamageBase(1);
    }
    
    maxPhaserDamage()
    {
        return Klingon.MaxPhaserMultiplier * this.phaserDamageBase(1);
    }

    toString()
    {
        return "+K+";
    }
    
    static maxInstancesQuadrant()
    {
        return 4;
    }

    static quadrantInstanceProbabilities()
    {
        return [.9,  
                .025,
                .025,
                .0125,
                .00625
        ];
    }

    static maxInstancesGame()
    {
        return 18;
    }

    static minInstancesGame()
    {
        return minKlingonsGame;
    }
}

Klingon.shieldDeflectionPercent = .15;
Klingon.InstancesDestroyed = 0;
Klingon.MaxPhaserMultiplier = 3;
Klingon.MinPhaserMultiplier = 2;

// ------- Star.js ------- 
class Star extends GameObject
{
    constructor()
    {
        super(Star);
    }

    onTorpedoHit(game)
    {
        console.log("hit a star");
        gameOutputAppend("\nReport from sector " + this.sectorString(this.sectorX, this.sectorY));
        gameOutputAppend("The star absorbs the torpedo without a trace.");
    }

    toString()
    {
        return "*";
    }

    static maxInstancesQuadrant()
    {
        return 9;//12;
    }
}

// ------- Enterprise.js ------- 
class ShipComponent
{
    constructor (componentName, damProb)
    {
        this.componentHealth = 0.0; //percent
        this.componentName = componentName;
        this.componentDamageProbability = damProb;
    }
}

class Enterprise extends GameObject
{
    componentDamageProbabilities()
    {
        var probArray = [];

        for (var key in this.components)
        {
            console.log("" + this.components[key].componentDamageProbability);
            probArray.push(this.components[key].componentDamageProbability);
        }

        console.assert(probArray.length == Object.keys(this.components).length);
        return probArray;
    }

    constructor()
    {
        super(Enterprise);
        this.torpedoes = Enterprise.StartTorpedoes;
        this.shields = Enterprise.StartShields;

        this.freeEnergy = Enterprise.StartEnergy;

        this.components =   {
                                WarpEngines : new ShipComponent("Warp Engines", .0625), 
                                ShortRangeSensors: new ShipComponent("Short Range Sensors", .0625),
                                LongRangeSensors: new ShipComponent("Long Range Sensors", .25),
                                PhaserControl : new ShipComponent("Phaser Control", .0625),
                                PhotonTubes : new ShipComponent("Photon Tubes", .125),
                                DamageControl : new ShipComponent("Damage Control", .0625),
                                ShieldControl : new ShipComponent("Shield Control", .125), 
                                LibraryComputer : new ShipComponent("Library Computer", .25)
                            }

        this.hitNoShields = false;
        this.docked = false;
        this.sensorHistory = new SensorHistory();
    }

    // called on navigation
    autoRepairComponents()
    {
        for (var key in this.components)
        {
            let oldHealth = this.components[key].componentHealth;
            this.components[key].componentHealth += (randomInt(Enterprise.MinComponentRepairPerTurn, Enterprise.MaxComponentRepairPerTurn) / 100);
            this.components[key].componentHealth = Math.min(this.components[key].componentHealth, 1.0);

            if (this.components[key].componentHealth == 1.0 && oldHealth != 1.0)
            {
                gameOutputAppend("" + this.components[key].componentName + " has been fully repaired!");
            }
        }
    }

    repairRandomComponent()
    {
        var damagedComponents = [];

        for (var key in this.components)
        {
            if (this.components[key].componentHealth != 1.0)
            {
                damagedComponents.push(this.components[key]);
            }
        }

        console.log("Enterprise has " + damagedComponents.length + " damaged components");

        if (!damagedComponents.length)return;

        let componentToRepair = damagedComponents[randomInt(0, damagedComponents.length-1)];
        componentToRepair.componentHealth = 1.0;

        gameOutputAppend(componentToRepair.componentName + " has been fully repaired!");
    }

    undock(starbase)
    {
        this.docked = false;
    }

    dockWithStarbase(starbase)
    {
        console.log("dock with starbase");

        this.torpedoes = Enterprise.StartTorpedoes;
        this.freeEnergy = Enterprise.StartEnergy - this.shields;
        this.docked = true;

        gameOutputAppend("Docked with starbase.  Torpedoes and energy replenished.  The starbase's shields protect the Enterprise.");

        this.repairRandomComponent();
    }

    // is our total energy less than the minimum energy cost to get anywhere?
    isStranded()
    {
        return (this.freeEnergy + this.shields) < this.warpEnergyCost(1); // energy cost to travel one square.
    }

    isDestroyed()
    {
        return this.hitNoShields;
    }

    // suggested minimum shield level for the current battlefield, to survive at least one round of enemy fire
    suggestedMinShieldLevel(enemyList)
    {
        let possibleDamageSum = 0.0;

        for (var x in enemyList)
        {
            possibleDamageSum += enemyList[x].maxPhaserDamage();
        }

        return possibleDamageSum;
    }

    // is it possible for a single round of enemy fire to destroy the enterprise?
    isShieldLevelCritical(enemyList)
    {
        return !this.docked && (this.shields < this.suggestedMinShieldLevel(enemyList));
    }

    warpEnergyCost(numSectors)
    {
        return Enterprise.EnergyCostPerSector * numSectors;
    }
    
    // assumes that the input value has been previously checked for the appropriate range and available value
    setShieldLevel(newShields)
    {
        if ((newShields > this.freeEnergy + this.shields) || newShields < 0.0)
        {
            throw "Invalid value for shield level"; 
        }

        this.freeEnergy += this.shields - newShields;
        this.shields = newShields;
    }

    toString()
    {
        return "<*>";
    }

    static maxInstancesGame()
    {
        return 1;
    }

    static maxInstancesQuadrant()
    {
        return 1;
    }

    static minInstancesGame()
    {
        return 1;
    }

    conditionString(game)
    {
        if (game.currentQuadrant.countEntitiesOfType(Klingon))
        {
            return "RED";
        }

        if ((this.freeEnergy + this.shields) < .1 * Enterprise.StartEnergy)
        {
            return "YELLOW";
        }

        return "GREEN";
    }

    passthroughDamage(energy)
    {
        // we want to map (as a starting guess, pre balance) 500 energy to a total wipeout of a component
        let passthroughDamage = energy * randomFloat(.001, .002);

        // random component index
        let idx = randomWithProbabilities(this.componentDamageProbabilities());

        let component = this.components[Object.keys(this.components)[idx]];

        component.componentHealth -= Math.min(passthroughDamage, component.componentHealth);

        gameOutputAppend("" + component.componentName + " hit.  Now at " + Math.floor(component.componentHealth*100) + "% integrity" );
    }

    onPhaserHit(energy, game)
    {
        if (this.docked)
        {
            gameOutputAppend("The starbase shields protect you from the incoming phaser fire.");
            return;
        }

        let hitRatio = energy / this.shields;

        if (this.shields < energy)
        {
            this.hitNoShields = true;
            this.shields = 0.0;

            return;
        }

        if ((hitRatio > Enterprise.DamagePassthroughRatio) || Math.random() < Enterprise.RandomPassthroughRatio)
        {
            this.passthroughDamage(energy);
        }

        this.shields -= energy;
        gameOutputAppend("Shields at " + this.shields);
    }

    firePhasers(energy, game)
    {
        console.log("fire phasers");

        let targets = [];

        var x;
        for (x in Enterprise.PhaserTargets)
        {
            targets.push(...game.currentQuadrant.getEntitiesOfType(Enterprise.PhaserTargets[x]));
        }

        console.assert(energy <= this.freeEnergy);

        this.freeEnergy -= energy;

        gameOutputAppend("Firing phasers at " + targets.length + " targets.");
        console.assert(targets.length > 0);
        let damagePerTarget = energy / targets.length;

        var x;
        for (x in targets)
        {
            console.log("target");
            let target = targets[x];
            let dist = this.distanceToObject(target);

            let damageAttenuated = damagePerTarget / dist;
            let damageFinal = Math.floor(randomFloat(2.0, 3.0) * damageAttenuated);

            target.onPhaserHit(damageFinal, game);
        }
    }

    fireTorpedo(game, angle)
    {
        if (this.freeEnergy >= Enterprise.TorpedoEnergyCost)
        {
            let torpedoIntersection = game.currentQuadrant.intersectionTest(this.sectorX, this.sectorY, angle);
            this.torpedoes--;
            this.freeEnergy -= Enterprise.TorpedoEnergyCost;
            
            if (torpedoIntersection.intersects != null)
            {
               torpedoIntersection.intersects.onTorpedoHit(game);
            }
            else
            {
                gameOutputAppend("The torpedo missed!");
            }
        }
        else
        {
            //not enough energy
            gameOutputAppend("Not enough energy to fire torpedoes!");
        }
    }

    lrsStringEntityType(galaxyMap, entityType)
    {
        let border = "-------------------";
        let rval = border + '\n';

        for (let y = this.quadrantY - 1; y <= this.quadrantY + 1; y++)
        {
            rval += "|";
            for (let x = this.quadrantX - 1; x <= this.quadrantX + 1; x++)
            {
                let quadrant = galaxyMap.lookup(x, y);
                if (quadrant)
                {
                    let k = quadrant.countEntitiesOfType(entityType);

                    if (x == this.quadrantX && y == this.quadrantY)
                    {
                        k = "" + k + "E";
                    }

                    rval += " " + padStringToLength(""+k, 3) + " |";
                }
                else
                {
                    rval += " *** |";
                }
            }
            rval += "\n" + border + "\n";
        }
        return rval;
    }

    // long range scan
    lrsString(galaxyMap)
    {
        let rval = "KLINGONS\t\tSTARS\t\t\tSTARBASES\n";

        let klingonLRS = this.lrsStringEntityType(galaxyMap, Klingon);
        let starLRS = this.lrsStringEntityType(galaxyMap, Star);
        let starbaseLRS = this.lrsStringEntityType(galaxyMap, StarBase);

        let klingonLRSLines = klingonLRS.split('\n');
        let starLRSLines = starLRS.split('\n');
        let starbaseLRSLines = starbaseLRS.split('\n');

        console.assert(klingonLRSLines.length == starLRSLines.length);
        for (var x in klingonLRSLines)
        {
            rval += klingonLRSLines[x] + "\t" + starLRSLines[x] + "\t" + starbaseLRSLines[x] + '\n';
        }

        return rval;
    }

    warp(sectorXEnd, sectorYEnd, sectorsToTravel, game)
    {
        let energyRequired = this.warpEnergyCost(sectorsToTravel);

        if (this.freeEnergy < energyRequired)
        {
            gameOutputAppend("Not enough energy free to complete maneuver!");
            return;
        }

        let intersection = game.currentQuadrant.intersectionTest2(this.sectorX, this.sectorY, sectorXEnd, sectorYEnd)
        //game.currentQuadrant.intersectionTest(this.sectorX, this.sectorY, angle, sectorsToTravel);
           
        this.sectorX = Math.floor(intersection.lastX);
        this.sectorY = Math.floor(intersection.lastY);

        if (intersection.intersects != null)
        {
            gameOutputAppend("Obstruction ahead.  Exiting warp.");
        }

        let actualEnergy = this.warpEnergyCost(intersection.stepIterations);

        // get the energy cost of the sectors we actually travelled
        this.freeEnergy -= actualEnergy
    }

    damageReport()
    {
        gameOutputAppend("DAMAGE REPORT:\n");
        gameOutputAppend("Component Integrity:")
        for (var key in this.components)
        {
            let component = this.components[key];
            gameOutputAppend("" + component.componentName + " : " + Math.round(component.componentHealth * 100) + "%");
        }

        gameOutputAppend("\n\nNOTES:\nRepair crews can repair 1-5% damage per stardate.  A starbase will fully repair a single component every stardate.");

        // torpedo tube functionality notes
        if (this.components.PhotonTubes.componentHealth > Enterprise.torpedoTubesDamagedThreshold)
        {
        }
        else if (this.components.PhotonTubes.componentHealth > Enterprise.torpedoTubesDisabledThreshold)
        {
            gameOutputAppend("Due to damage, torpedo targeting computer is nonfunctional.  You will need to input torpedo trajectories manually until the system is repaired.");
        }
        else
        {
            gameOutputAppend("Torpedo tubes too damaged to fire.");
        }

        // short range scan functionality notes
        let srsHealthOK = this.components.ShortRangeSensors.componentHealth > Enterprise.SRSFullyFunctionalHealth;
        if (!srsHealthOK)
        {
            gameOutputAppend("Short range sensors are damaged.  Map display may be corrupted.");
        }

        // library computer
        if (this.components.LibraryComputer.componentHealth <= Enterprise.libraryComputerDamagedThreshold)
        {
            gameOutputAppend("Ship computer is too damaged to access maps.");
        }
                    

        /*
        WarpEngines : new ShipComponent("Warp Engines", .0625), 
        xx ShortRangeSensors: new ShipComponent("Short Range Sensors", .0625),
        LongRangeSensors: new ShipComponent("Long Range Sensors", .25),
        PhaserControl : new ShipComponent("Phaser Control", .0625),
        PhotonTubes : new ShipComponent("Photon Tubes", .125),
        DamageControl : new ShipComponent("Damage Control", .0625),
        ShieldControl : new ShipComponent("Shield Control", .125), 
        xx LibraryComputer : new ShipComponent("Library Computer", .25)
        */

    }
}

Enterprise.StartTorpedoes = 10;
Enterprise.StartEnergy = 3000;
Enterprise.StartShields = 0;
Enterprise.TorpedoEnergyCost = 2;
Enterprise.PhaserTargets = [Klingon];       // future extension : this list could be dynamic based on evolving gameplay alliances, etc :) 
Enterprise.SRSFullyFunctionalHealth = .7;   // short range scan fully functional above this health
Enterprise.SRSMinChanceCorrupt = .1;        // For a particular sector on the map, minimum chance it'll be corrupt when integrity is high
Enterprise.SRSMaxChanceCorrupt = .75;       // For a particular sector on the map, maximum chance it'll be corrupt when integrity is low
Enterprise.EnergyCostPerSector = 1.0;       // Warp cost per sector moved
Enterprise.EnergyCostPerQuadrant = 10.0;       // Warp cost per quadrant moved
Enterprise.DamagePassthroughRatio = .25;    // if damage is 25% of shields or more, pass damage through to components
Enterprise.RandomPassthroughRatio = .25;    // 25% chance that damage will pass through to ship components regardless of shields

Enterprise.torpedoTubesDamagedThreshold = .5; // 50% health = automatic targeting is down.
Enterprise.torpedoTubesDisabledThreshold = .25; // 25% health = can't fire torpedoes.
Enterprise.libraryComputerDamagedThreshold = .25; // 25% health = can't access maps.

Enterprise.MinComponentRepairPerTurn = 1;  // integrity min autorepair per component
Enterprise.MaxComponentRepairPerTurn = 5;  // integrity max autorepair per component


// ------- Quadrant.js ------- 
class Quadrant
{
    constructor(widthSectorsIn, heightSectorsIn, x, y)
    {
        checkArgumentsDefinedAndHaveValue(arguments);
        this.width = widthSectorsIn;
        this.height = heightSectorsIn;
        this.quadrantEntities = new Array();
        this.x = x;
        this.y = y;
    }

    populateFromJSData(entitiesQuadrantJS)
    {
        var x;
        for (x in entitiesQuadrantJS.quadrantEntities)
        {
            let entData = entitiesQuadrantJS.quadrantEntities[x];

            // we construct and insert the enterprise entity elsewhere.
            if (entData.entityType != "Enterprise")
            {
                let ctype = EntityMap.get(entData.entityType);

                let entityObj = new ctype(); 
                Object.assign(entityObj, entData);

                this.quadrantEntities.push(entityObj);
            }
        }
    }

    removeEntity(entity)
    {
        let rmindex = this.quadrantEntities.indexOf(entity);
        if (rmindex == -1)throw "Entity not found";
        this.quadrantEntities.splice( rmindex, 1 );
    }

    entityAtLocation(nextXCoord, nextYCoord)
    {
        nextXCoord = Math.floor(nextXCoord);
        nextYCoord = Math.floor(nextYCoord);
        
        for (var x in this.quadrantEntities)
        {
            let objTest = this.quadrantEntities[x];

            if ((objTest.sectorX == nextXCoord) && (objTest.sectorY == nextYCoord))
            {
                return objTest;
            }
        }

        return null;
    }

    // return a tuple containing
    // the last sector prior to the intersection
    // and the intersection object (null if none)
    intersectionTest2(sectorX, sectorY, sectorXEnd, sectorYEnd)
    {
        checkArgumentsDefinedAndHaveValue(arguments);

        // polar to euclidean coordinates
        let xVec = sectorXEnd - sectorX;
        let yVec = sectorYEnd - sectorY;

        // we'll step through the grid in in increments of one cell; -1 if the x / y direction are negative
        let xNextF = xVec > 0.0 ? 1.0 : -1.0;
        let yNextF = yVec > 0.0 ? 1.0 : -1.0;

        // start in the middle of the cell.
        let startCoordX = Math.floor(sectorX) + .5;
        let startCoordY = Math.floor(sectorY) + .5;
        let endCoordX = Math.floor(sectorXEnd) + .5;
        let endCoordY = Math.floor(sectorYEnd) + .5;

        // return values
        let lastCellBeforeIntersectionX = startCoordX;
        let lastCellBeforeIntersectionY = startCoordY;
        let intersectionObject = null;

        //console.log("start coord " + (startCoordX) + " " + (startCoordY));
        //console.log("end coord " + (endCoordX) + " " + (endCoordY));
        //console.log("vec " + (xVec) + " " + (yVec));

        var nextXCoord = 0;
        var nextYCoord = 0;

        let currentT = 0.0;

        var steps = 0;
        while (true)
        {
            // we have, given a start coordinate and a direction vector, the parametric equation of a line
            // Pt = P0 + D*t
            // From this we can derive the parameter t at which the line will reach a particular X or Y value
            // X_t = X_0 + V_x * t
            // Y_t = Y_0 + V_y * t
            // implies
            // (X_t - X_0) / V_x = t
            // or
            // (Y_t - Y_0) / V_y = t
            // so we can figure out what the next cell on the x axis is (current plus or minus one) and figure
            // out the t parameter where the line crosses it.  
            // We can do the same for the next call on the y axis.
            // Then, whichever cell has the lower t parameter the line crosses first.
            // Because there's a division and it's possible the direction vector has a zero component, we'll check for divide by zero

            nextXCoord = Math.floor(lastCellBeforeIntersectionX + xNextF);
            nextYCoord = Math.floor(lastCellBeforeIntersectionY + yNextF);

            //console.log("next " + nextXCoord + " " + nextYCoord);

            let tXBound = ((nextXCoord+.5) - startCoordX) / xVec;
            let tYBound = ((nextYCoord+.5) - startCoordY) / yVec;

            tXBound = Math.abs(xVec) > .00001 ?  tXBound : Number.MAX_VALUE;
            tYBound = Math.abs(yVec) > .00001 ?  tYBound : Number.MAX_VALUE;

            if (tXBound < tYBound) // hit the x boundary first.
            {
                //console.log("xb " + tXBound);
                currentT = tXBound;
                nextYCoord = startCoordY + yVec * currentT;
            }
            else
            {
                //console.log("yb");
                currentT = tYBound;
                nextXCoord = startCoordX + xVec * currentT;
            }

            if (currentT > 1.0)
            {
                //console.log("Exceeded jump range "+ currentT);
                break;
            }

            intersectionObject = this.entityAtLocation(nextXCoord, nextYCoord);

            if (intersectionObject != null)
            {
                //console.log("intersection return");
                break;
            }

            if (nextXCoord < 0 || nextXCoord >= quadrantWidthSectors || nextYCoord < 0 || nextYCoord >= quadrantHeightSectors)
            {
                //console.log("next out of bounds " + nextXCoord + " " + nextYCoord);
                break;
            }

            //console.log("T is at " + currentT);
            lastCellBeforeIntersectionX = nextXCoord;
            lastCellBeforeIntersectionY = nextYCoord;

            steps++;

            //console.log("cell step" + (lastCellBeforeIntersectionX) + " " + (lastCellBeforeIntersectionY));
        }

        //console.log("cell end " + (lastCellBeforeIntersectionX) + " " + (lastCellBeforeIntersectionY)+ " " + intersectionObject);
        return {lastX : lastCellBeforeIntersectionX, lastY : lastCellBeforeIntersectionY, intersects : intersectionObject, stepIterations:steps, nextX : nextXCoord, nextY : nextYCoord};
    }

    // return a tuple containing
    // the last sector prior to the intersection
    // and the intersection object (null if none)
    intersectionTest(sectorX, sectorY, angleDegrees, maxSectorsToTravel = Number.MAX_VALUE)
    {
        checkArgumentsDefinedAndHaveValue(arguments);
        // console.log(""+angleDegrees);

        // take angle in degrees to radians, then create a vector
        // start from 360 CCW because we have a top left origin (y axis goes down) internally
        // instead of y axis goes up like in your math textbook
        let angle = 360.0 - angleDegrees;

        let radians = angle * Math.PI / 180.0;

        // polar to euclidean coordinates
        let xVec = Math.cos(radians);
        let yVec = Math.sin(radians);

        // we'll step through the grid in in increments of one cell; -1 if the x / y direction are negative
        let xNextF = xVec > 0.0 ? 1.0 : -1.0;
        let yNextF = yVec > 0.0 ? 1.0 : -1.0;

        // start in the middle of the cell.
        let startCoordX = Math.floor(sectorX) + .5;
        let startCoordY = Math.floor(sectorY) + .5;

        // return values
        let lastCellBeforeIntersectionX = startCoordX;
        let lastCellBeforeIntersectionY = startCoordY;
        let intersectionObject = null;

        //console.log("start coord " + (startCoordX) + " " + (startCoordY));
        //console.log("vec " + (xVec) + " " + (yVec));

        var nextXCoord = 0;
        var nextYCoord = 0;

        var steps = 0;
        while (steps < maxSectorsToTravel)
        {
            // we have, given a start coordinate and a direction vector, the parametric equation of a line
            // Pt = P0 + D*t
            // From this we can derive the parameter t at which the line will reach a particular X or Y value
            // X_t = X_0 + V_x * t
            // Y_t = Y_0 + V_y * t
            // implies
            // (X_t - X_0) / V_x = t
            // or
            // (Y_t - Y_0) / V_y = t
            // so we can figure out what the next cell on the x axis is (current plus or minus one) and figure
            // out the t parameter where the line crosses it.  
            // We can do the same for the next call on the y axis.
            // Then, whichever cell has the lower t parameter the line crosses first.
            // Because there's a division and it's possible the direction vector has a zero component, we'll check for divide by zero

            nextXCoord = Math.floor(lastCellBeforeIntersectionX + xNextF);
            nextYCoord = Math.floor(lastCellBeforeIntersectionY + yNextF);

            //console.log("next " + nextXCoord + " " + nextYCoord);

            let tXBound = (nextXCoord - lastCellBeforeIntersectionX) / xVec;
            let tYBound = (nextYCoord - lastCellBeforeIntersectionY) / yVec;

            tXBound = Math.abs(xVec) > .00001 ?  tXBound : Number.MAX_VALUE;
            tYBound = Math.abs(yVec) > .00001 ?  tYBound : Number.MAX_VALUE;

            var currentT = 0.0;
            if (tXBound < tYBound)
            {
                //console.log("xb " + tXBound);
                nextYCoord = lastCellBeforeIntersectionY + yVec * tXBound;
            }
            else
            {
                //console.log("yb");
                nextXCoord = lastCellBeforeIntersectionX + xVec * tYBound;
            }

            intersectionObject = this.entityAtLocation(nextXCoord, nextYCoord);

            if (intersectionObject != null)
            {
                //console.log("intersection return");
                break;
            }

            if (nextXCoord < 0 || nextXCoord >= quadrantWidthSectors || nextYCoord < 0 || nextYCoord >= quadrantHeightSectors)
            {
                //console.log("next out of bounds " + nextXCoord + " " + nextYCoord);
                break;
            }

            lastCellBeforeIntersectionX = nextXCoord;
            lastCellBeforeIntersectionY = nextYCoord;

            steps++;

            //console.log("cell step" + (1+lastCellBeforeIntersectionX) + " " + (1+lastCellBeforeIntersectionY));
        }

        //console.log("cell end " + (1+lastCellBeforeIntersectionX) + " " + (1+lastCellBeforeIntersectionY)+ " " + intersectionObject);
        return {lastX : lastCellBeforeIntersectionX, lastY : lastCellBeforeIntersectionY, intersects : intersectionObject, stepIterations:steps, nextX : nextXCoord, nextY : nextYCoord};
    }

    countEntitiesOfType(classtype)
    {
        var rval=0;
        for (var x in this.quadrantEntities)
        {
            if (this.quadrantEntities[x].constructor == classtype)
            {
                rval++;
            }
        }
        return rval;
    }

    getEntitiesOfType(classtype)
    {
        return this.quadrantEntities.filter(function(item){return item.constructor == classtype});
    }

    getAdjacentEntitiesOfType(adjacentToObj, classtype)
    {
        let sblist = this.getEntitiesOfType(classtype);
        return sblist.filter(function(sb){return sb.isAdjacentTo(adjacentToObj)});
    }

    klingonsFire(target, game)
    {
        let klist = this.getEntitiesOfType(Klingon);

        for (var x in klist)
        {
            klist[x].firePhasers(target, game);
        }
    }

    createEntities(entityTypes)
    {
        var entityIdx;
        for (entityIdx in entityTypes)
        {
            let entityType = entityTypes[entityIdx];

            let numEntities = entityType.randomCountForQuadrant(this.emptySquares(), this.countEntitiesOfType(entityType));

            for (let i =0; i < numEntities; i++ )
            {
                var ent = new entityType();
                this.addEntityInFreeSector(ent);
            }
        }
    }

    addEntityInFreeSector(entity)
    {
        entity.quadrantX = this.x;
        entity.quadrantY = this.y;
        entity.setLocationSector(this.getEmptySquare());
        this.quadrantEntities.push(entity);
    }

    addEntity(entity)
    {
        entity.quadrantX = this.x;
        entity.quadrantY = this.y;

        this.quadrantEntities.push(entity);
    }

    emptySquares()
    {
        return this.width*this.height - this.quadrantEntities.length;
    }

    getEmptySquare()
    {
        console.assert(this.width * this.height > this.quadrantEntities.length);

        if (this.quadrantEntities.length >= this.width*this.height)
        {
            return null;
        }

        let emptyFound = false;

        let testRandom = randomInt(0, (this.width*this.height)-1);

        while (!emptyFound)
        {
            let randomX = testRandom % this.width;
            let randomY = Math.floor(testRandom / this.height);

            var entityIdx;
            emptyFound = true;
            for (entityIdx in this.quadrantEntities)
            {
                let entity = this.quadrantEntities[entityIdx];
                if (entity.sectorX == randomX && entity.sectorY == randomY)
                {
                    emptyFound = false;
                    break;
                }
            }

            if (emptyFound)
            {
                return {x : randomX, y : randomY};
            }

            testRandom++;
        }
    }

    toString()
    {
        let borderStringPost = "   " + mapFooter(quadrantWidthSectors) + '\n';
        let borderStringPre = "   " + mapHeader(quadrantWidthSectors); 

        let quadrantStringGrid = new Grid(this.width, this.height, function(){return " ".padStart(sectorDisplayWidthChars, ' ')})

        var gameObjectIndex;
        for (gameObjectIndex in this.quadrantEntities)
        {
            let gameObject = this.quadrantEntities[gameObjectIndex];
            let objStr = gameObject.toString().padStart(sectorDisplayWidthChars, ' ');
            quadrantStringGrid.setValue(gameObject.sectorX, gameObject.sectorY, objStr);
        }

        let mapString = quadrantStringGrid.toString();

        return "<pre>" + borderStringPre + mapString + borderStringPost + "</pre>";
    }
}

// ------- GalaxyMap.js ------- 
class GalaxyMap extends Grid
{
    constructor(quadrantsX, quadrantsY, entityTypes)
    {
        checkArgumentsDefinedAndHaveValue(arguments);
        super(quadrantsX, quadrantsY, function(x, y){return new Quadrant(quadrantWidthSectors,quadrantHeightSectors, x, y)});

        this.createMinimumInstances(entityTypes, quadrantsX, quadrantsY);

        for (let i = 0; i < quadrantsX*quadrantsY; i++)
        {
            this.lookup1D(i).createEntities(entityTypes);
        }
    }

    static ConstructFromJSData(jsData)
    {
        let rval = new GalaxyMap(mapWidthQuadrants, mapHeightQuadrants, []);

        var x;
        for (x in jsData.contents)
        {
            let entitiesQuadrantJS = jsData.contents[x];

            rval.contents[x].populateFromJSData(entitiesQuadrantJS);
        }

        return rval;
    }

    mapString(galaxyMap, EntityType = Klingon, gameobject = null)
    {
        let border = "------";
        border = border.repeat(mapWidthQuadrants);
        let rval = border + '\n';

        for (let y = 0; y < mapHeightQuadrants; y++)
        {
            rval += "|";
            for (let x = 0; x < mapWidthQuadrants; x++)
            {
                let quadrant = galaxyMap.lookup(x, y);
                
                if (quadrant)
                {    
                    let k = quadrant.countEntitiesOfType(EntityType);

                    if (gameobject)
                    {
                        if (gameobject.quadrantX == x && gameobject.quadrantY == y)
                        {
                            // put an "E" on the map for the enterprise's current location
                            k += 'E';
                        }
                    }

                    rval += " " + padStringToLength(""+k, 3, ' ') + " |";
                }
                 else
                 {  console.log(" null");
                     rval += " *** |";
                 }
             }
             rval += "\n" + border + "\n";
         }
         return rval;
     }

    createMinimumInstances(entityTypes)
    {
        var x;
        for (x in entityTypes)
        {
            let etype = entityTypes[x];

            let instancesToCreate = etype.minInstancesGame() ;//- etype.Instances;

            // console.log("Creating min instances of " + etype.name + " : " + instancesToCreate);
            if (instancesToCreate > 0)
            {
                for (let i = 0; i < instancesToCreate; i++)
                {
                    let inst = new etype();
                    let randomQuadrant = randomInt(0, this.contents.length-1);

                    let instAssigned = false;
                    for (let quad = 0; quad < this.contents.length; quad++)
                    {
                        if (this.lookup1D(randomQuadrant).emptySquares())
                        {
                            this.lookup1D(randomQuadrant).addEntityInFreeSector(inst);
                            instAssigned = true;
                            break;
                        }

                        randomQuadrant = (randomQuadrant + 1 ) % this.contents.length;
                    }
                    
                    if (!instAssigned)
                    {
                        throw "Not enough space to assign minumum instances of " + etype.name;
                    }
                }
            }
        }
    }
}

// ------- SensorHistory.js ------- 
class SensorHistory extends Grid
{
    constructor()
    {
        super( mapWidthQuadrants, mapHeightQuadrants, function(){return {};} );
    }

    updateSensorHistory(EntityType, galaxyMap, startLocX, startLocY, endLocX, endLocY)
    {
        for (var y = startLocY; y <= endLocY; y++)
        {
            for (var x = startLocX; x <= endLocX; x++)
            {
                let quadrant = galaxyMap.lookup(x, y);

                if (quadrant)
                {
                    let ct = quadrant.countEntitiesOfType(EntityType);
                    this.lookup(x, y)[EntityType] = ct;
                }
            }
        }               
    }

    updateSensorHistoryForEntityTypes(EntityList, galaxyMap, startLocX, startLocY, endLocX, endLocY)
    {
        for (var x in EntityList)
        {
            let EntityType = EntityList[x];
            this.updateSensorHistory(EntityType, galaxyMap, startLocX, startLocY, endLocX, endLocY);
        }
    }

    mapString(EntityType = Klingon, gameobject = null)
    {
        let border = "------";
        border = border.repeat(mapWidthQuadrants);

        let rval = border + '\n';

        for (let y = 0; y < this.height; y++)
        {
            rval += "|";
            for (let x = 0; x < this.width; x++)
            {
                let quadrantDict = this.lookup(x, y);
                
                if (quadrantDict)
                {    
                    var k = "";

                    if (EntityType in quadrantDict)
                    {
                        k += quadrantDict[EntityType]; // integer count of the entity type
                    }
                    else
                    {
                        k += "?";
                    }

                    if (gameobject)
                    {
                        if (gameobject.quadrantX == x && gameobject.quadrantY == y)
                        {
                            // put an "E" on the map for the enterprise's current location
                            k += 'E';
                        }
                    }

                    rval += " " + padStringToLength(""+k, 3, ' ') + " |";
                }
                else
                {  console.log(" null");
                    rval += " *** |";
                }
             }
             rval += "\n" + border + "\n";
         }
         return rval;
     }
}

// ------- Menu.js ------- 
class MenuOption
{
    constructor(option, separator, description, payload)
    {
        this.option = option.toString();
        this.separator = separator;
        this.description = description;
        this.payload = payload;
        this.enabled = true;
    }

    compare(testString)
    {
        return testString.toLowerCase() == this.option.toLowerCase();
    }

    toString()
    {
        return this.option + this.separator + this.description + '\n';
    }
}

class Menu
{
    constructor()
    {
        this.options = [];
    }

    getSelectedOption(optionText)
    {
        for (var x in this.options)
        {
            if (this.options[x].compare(optionText))
            {
                return this.options[x];
            }
        }
        return null;
    }

    invalidOption()
    {
        gameOutputAppend("Come again, captain?");
        return false;
    }

    chooseOption(optionText)
    {
        var menuopt = this.getSelectedOption(optionText);
        if (menuopt)
        {
            return menuopt.payload();
        }
        return this.invalidOption(optionText);
    }

    toString()
    {
        var rstring = "ENTER ONE OF THE FOLLOWING:\n";

        for (var x in this.options)
        {
            if (this.options[x].enabled)
            {
                rstring += this.options[x];
            }
        }

        return rstring;
    }
}


// ------- MainMenu.js ------- 
class MainMenu extends Menu
{
    constructor(trekgame)
    {
        super();

        this.options = [];

        this.options.push
        (
            new MenuOption
            (
                "0",
                ") ",
                "DOCK WITH STARBASE",
                function()
                {
                    let adjacentStarbases = trekgame.currentQuadrant.getAdjacentEntitiesOfType(trekgame.enterprise, StarBase);
                    console.assert(adjacentStarbases.length);

                    let sb = adjacentStarbases[0];

                    trekgame.enterprise.dockWithStarbase(sb);

                    trekgame.showDockMenu(sb);

                    trekgame.advanceStardate(1.0);

                    return false;
                }
            ),
            new MenuOption
            (
                "1",
                ") ",
                "NAVIGATION",
                function()
                {
                    gameOutputAppend("Navigation");

                    let navigationMenu = new Menu();
                    navigationMenu.options.push
                    (
                        new MenuOption
                        (
                            "1",
                            ") ",
                            "SHORT RANGE JUMP (1 STARDATE)",
                            function()
                            {
                                trekgame.awaitInput("Enter destination subsector (X coordinate)", 2, trekgame.navigationHandlerShortRangeX);
                                return false;
                            }
                        ),
                        new MenuOption
                        (
                            "2",
                            ") ",
                            "LONG RANGE JUMP  (1 STARDATE)",
                            function()
                            {
                                trekgame.awaitInput("Enter destination sector X coordinate. Enter a value between 1 and " + mapWidthQuadrants, 2, trekgame.navigationHandlerLongRangeX);
                                return false;
                            }
                        )
                    );

                    trekgame.awaitInput(navigationMenu.toString(), 1, function(inputline){return navigationMenu.chooseOption(inputline);});

                    //trekgame.awaitInput("Enter heading (degrees).", 3, trekgame.navigationHandler);
                }
            ), 

            new MenuOption
            (
                "2",
                ") ",
                "LONG RANGE SENSORS (1 STARDATE)",
                function()
                {
                    gameOutputAppend("Long Range Scan");
                    gameOutputAppend("Adjacent sectors have been scanned.  The ship's computer has been updated with the following information:\n");
                    gameOutputAppend(trekgame.enterprise.lrsString(trekgame.galaxyMap));

                    var sh = trekgame.enterprise.sensorHistory;
                    sh.updateSensorHistoryForEntityTypes
                    (
                        [Star, Klingon], 
                        trekgame.galaxyMap, 
                        trekgame.enterprise.quadrantX-1, 
                        trekgame.enterprise.quadrantY-1, 
                        trekgame.enterprise.quadrantX+1, 
                        trekgame.enterprise.quadrantY+1
                    );

                    trekgame.currentQuadrant.klingonsFire(trekgame.enterprise, trekgame);
                    trekgame.advanceStardate(1.0);
                }
            ),

            new MenuOption
            (
                "3",
                ") ",
                "PHASERS",
                function()
                {
                    gameOutputAppend("Fire phasers");
                    if (trekgame.currentQuadrant.countEntitiesOfType(Klingon))
                    {
                        gameOutputAppend("Enter the energy to commit to the phasers.");
                        gameOutputAppend("Total available : " + trekgame.enterprise.freeEnergy);
                        trekgame.awaitInput("Energy:", 4, trekgame.phaserHandler);
                    }
                    else
                    {
                        gameOutputAppend("No enemies detected in this sector, captain.");
                    }
                }
            ),

            new MenuOption
            (
                "4",
                ") ",
                "PHOTON TORPEDOES",
                function()
                {
                    gameOutputAppend("Fire torpedoes");
                    if (trekgame.enterprise.torpedoes <= 0)
                    {
                        gameOutputAppend("We're out of torpedoes, captain!");
                    }
                    else if (trekgame.enterprise.components.PhotonTubes.componentHealth > Enterprise.torpedoTubesDamagedThreshold)
                    {
                        // automatic targeting enabled. push a menu of targets.
                        console.log("auto targeting path");

                        let torpMenu = new TorpedoMenu(trekgame.currentQuadrant.getEntitiesOfType(Klingon), trekgame);

                        trekgame.awaitInput(torpMenu.toString(), 1, function(inputline){return torpMenu.chooseOption(inputline);});
                    }
                    else if (trekgame.enterprise.components.PhotonTubes.componentHealth > Enterprise.torpedoTubesDisabledThreshold)
                    {
                        gameOutputAppend("Due to damage, torpedo targeting computer is nonfunctional.");
                        gameOutputAppend("Enter torpedo heading manually (in degrees).");
                        trekgame.awaitInput("Torpedo Heading (degrees)", 3, trekgame.torpedoHandler);
                    }
                    else
                    {
                        gameOutputAppend("Torpedo tubes too damaged to fire!");
                    }
                }
            ),

            new MenuOption
            (
                "5",
                ") ",
                "SHIELD CONTROL",
                function()
                {
                    gameOutputAppend("Configure shields");
                    gameOutputAppend("Enter the new energy level for the shields.");
                    gameOutputAppend("Total available is : " + (trekgame.enterprise.freeEnergy + trekgame.enterprise.shields));
                    
                    if (trekgame.currentQuadrant.countEntitiesOfType(Klingon))
                    {
                        let klingonList = trekgame.currentQuadrant.getEntitiesOfType(Klingon);

                        let suggestedShieldLevel = trekgame.enterprise.suggestedMinShieldLevel(klingonList);

                        gameOutputAppend("Based on current combat conditions, the ship's computer suggests a minimum shield energy level of " + suggestedShieldLevel);
                    }

                    trekgame.awaitInput("New shield level:", 4, trekgame.shieldHandler);
                }
            ),

            new MenuOption
            (
                "6",
                ") ",
                "SHIP'S COMPUTER",
                function()
                {
                    return trekgame.awaitInput(trekgame.computerMenu.toString(), 1, function(inputline){return trekgame.computerMenu.chooseOption(inputline);});
                }
            ),

            new MenuOption
            (
                "7",
                ") ",
                "RESIGN YOUR COMMAND",
                function()
                {
                    gameOutputAppend("Resign command");
                    trekgame.awaitInput("Are you sure you want to end your current game and erase your autosave? (Y/N)", 1, trekgame.endGameHandler);
                    return;
                }
            )
        );

        this.dockOption = this.options[0];
        this.dockOption.enabled = false;
    }
}



// ------- TorpedoMenu.js ------- 
class TorpedoMenu extends Menu
{
    constructor(targetList, trekgame)
    {
        super();

        this.options = [];

        for (var x = 0; x < targetList.length; x++)
        {
            let targetHeading = trekgame.enterprise.angleToObject(targetList[x]);

            this.options.push
            (
                new MenuOption
                (
                    x + 1,
                    ") ",
                    "TARGET AT SUBSECTOR ("+targetList[x].sectorString() + ") : AT HEADING " + Math.round(targetHeading) + " DEGREES",
                    function()
                    {
                        trekgame.enterprise.fireTorpedo(trekgame, targetHeading);
                        trekgame.currentQuadrant.klingonsFire(trekgame.enterprise, trekgame);
                        return true;
                    }
                )
            );
        }

        this.options.push
        (
            new MenuOption
            (
                this.options.length + 1, 
                ") ",
                "MANUAL TARGETING",
                function()
                {
                    gameOutputAppend("Enter torpedo heading manually (in degrees).");
                    trekgame.awaitInput("Torpedo Heading (degrees)", 3, trekgame.torpedoHandler);
                    return false;
                }
            )
        );

        this.options.push
        (
            new MenuOption
            (
                this.options.length + 1, 
                ") ",
                "BACK",
                function()
                {
                    console.log("back button");
                    return true;
                }
            )
        );
    }
}

// ------- ShipComputer.js ------- 
class ShipComputerMenu extends Menu
{
    constructor(trekGame)
    {
        super();
        this.options = [];

        this.options.push(

            new MenuOption
            (
                "1",
                ") ",
                "DAMAGE REPORT",
                function()
                {
                    trekGame.enterprise.damageReport();
                    return true;
                }
            ),

            new MenuOption
            (
                "2",
                ") ",
                "STARBASE MAP",
                function()
                {
                    if (trekGame.enterprise.components.LibraryComputer.componentHealth <= Enterprise.libraryComputerDamagedThreshold)
                    {
                        gameOutputAppend("Ship's computer too damaged to access maps.");
                        return true;
                    }

                    gameOutputAppend("MAP OF FEDERATION STARBASES");
                    gameOutputAppend(trekGame.galaxyMap.mapString(trekGame.galaxyMap, StarBase, trekGame.enterprise));
                    return true;
                }
            ),

            new MenuOption
            (
                "3",
                ") ",
                "KLINGONS MAP",
                function()
                {
                    if (trekGame.enterprise.components.LibraryComputer.componentHealth <= Enterprise.libraryComputerDamagedThreshold)
                    {
                        gameOutputAppend("Ship's computer too damaged to access maps.");
                        return true;
                    }

                    gameOutputAppend("SENSOR RECORDS OF KLINGONS IN EACH SECTOR");
                    gameOutputAppend(trekGame.enterprise.sensorHistory.mapString(Klingon, trekGame.enterprise));
                    return true;
                }
            ),

            new MenuOption
            (
                "4",
                ") ",
                "STAR DENSITY MAP",
                function()
                {
                    if (trekGame.enterprise.components.LibraryComputer.componentHealth <= Enterprise.libraryComputerDamagedThreshold)
                    {
                        gameOutputAppend("Ship's computer too damaged to access maps.");
                        return true;
                    }
                    
                    gameOutputAppend("SENSOR RECORDS SHOWING NUMBER OF STARS IN EACH SECTOR");
                    gameOutputAppend(trekGame.enterprise.sensorHistory.mapString(Star, trekGame.enterprise));
                    return true;
                }
            ),



            new MenuOption
            (
                "5",
                ") ",
                "BACK",
                function()
                {
                    return true;
                }
            )

        );
    }
}

// ------- TrekGame.js ------- 
class TrekGame
{
    static ConstructFromJSData(jsData)
    {
        try
        {
            let gamerval = Object.create(TrekGame.prototype);
            Object.assign(gamerval, jsData);

            gamerval.enterprise = Object.create(Enterprise.prototype);
            Object.assign(gamerval.enterprise, jsData.enterprise);

            gamerval.enterprise.sensorHistory = new SensorHistory();// Object.create(SensorHistory);
            Object.assign(gamerval.enterprise.sensorHistory, jsData.enterprise.sensorHistory);

            gamerval.galaxyMap = GalaxyMap.ConstructFromJSData(jsData.galaxyMap);

            // console.log("galaxy map : " + gamerval.galaxyMap);

            gamerval.currentQuadrant = gamerval.galaxyMap.lookup(gamerval.enterprise.quadrantX, gamerval.enterprise.quadrantY);

            gamerval.currentQuadrant.addEntity(gamerval.enterprise);

            gamerval.createMenus();

            gamerval.checkStarbaseDock();

            if (gamerval.enterprise.docked)
            {
                gamerval.showDockMenu();
            }
            else
            {
                gamerval.setInputPrompt(gamerval.mainMenu.toString());
            }

            gamerval.updateDisplay();
            return gamerval;
        }
        catch(err)
        {
            console.log("Corrupt save file.  Erasing.");
            autosave(null);
            gameOutputAppend("Corrupt save file.  Refresh page to start new game.");
        }
    }

    constructor()
    {
        this.gameOver = false;

        this.galaxyMap = new GalaxyMap(mapWidthQuadrants, mapHeightQuadrants, TrekGame.EntityTypes);
        
        this.enterprise = new Enterprise();

        // start in a random quadrant
        this.enterprise.quadrantX = randomInt(0, mapWidthQuadrants - 1);
        this.enterprise.quadrantY = randomInt(0, mapHeightQuadrants - 1);
        this.enterprise.sectorX = 0;
        this.enterprise.sectorY = 0;
        
        this.currentQuadrant = this.galaxyMap.lookup(this.enterprise.quadrantX, this.enterprise.quadrantY);

        this.currentQuadrant.addEntityInFreeSector(this.enterprise);

        // pick a stardate between the start and end of TOS
        this.starDate = randomInt(1312, 5928);
        this.starDateBegin = this.starDate;
        this.endStarDate = this.starDate + TrekGame.BaseMissionTime + randomInt(0, TrekGame.MissionTimeSpread);

        this.createMenus();
        this.setInputPrompt(this.mainMenu.toString());

        this.updateGame();

        autosave(this);

        this.printStory();
    }

    showDockMenu(sb)
    {
        let dockMenu = new Menu();
        let trekgame = this;

        dockMenu.options.push
        (
            new MenuOption
            (
                "1",
                ") ", 
                "STAY DOCKED (1 STARDATE, REPAIRS A COMPONENT)",
                function()
                {
                    trekgame.advanceStardate(1.0);
                    trekgame.enterprise.repairRandomComponent();
                    return false;
                }
            ),
            new MenuOption
            (
                "2",
                ") ",
                "UNDOCK",
                function()
                {
                    trekgame.enterprise.undock(sb);
                    gameOutputAppend("Undocking from starbase");

                    // explicitly doesn't take a stardate to do this action.

                    return true;
                }
            ),
            new MenuOption
            (
                "3", ") ", "DAMAGE REPORT", 
                function()
                {
                    trekgame.enterprise.damageReport();
                    return false;
                }
            ),
        );

        this.awaitInput
        (
            dockMenu.toString(),
            1,
            function(inputline){return dockMenu.chooseOption(inputline);}
        );
    }

    starbasesScan()
    {
        var sh = this.enterprise.sensorHistory;

        for (var x in StarBase.starbaseList)
        {
            let starbase = StarBase.starbaseList[x];
            sh.updateSensorHistoryForEntityTypes
            (
                [Star, Klingon], 
                this.galaxyMap, 
                starbase.quadrantX-1, 
                starbase.quadrantY-1, 
                starbase.quadrantX+1, 
                starbase.quadrantY+1
            );
        }
    }
    
    generateScore(gameWon)
    {
        let baseScore = 1000 * (Klingon.InstancesDestroyed / (1 + this.starDate - this.starDateBegin));
        let winMultiplier = 2.0;

        return gameWon ? Math.round(winMultiplier * baseScore) : Math.round(baseScore);
    }

    destroyKlingon(k)
    {
        gameOutputAppend("Klingon Fighter Destroyed");
        this.currentQuadrant.removeEntity(k);
        Klingon.Instances--;
        Klingon.InstancesDestroyed++;
    }

    printStory()
    {
        var storyString = "The stardate is " + this.starDate + ".\n\nYou are the captain of the USS Enterprise.  " +
        "You have received word from Starfleet command of a plot by Klingon spies to destroy all the Federation " +
        "starbases in the region so the Klingon Empire can assume control.\n\n";

        storyString += 
        "The Federation is in danger and you are the only ship in range.\n\n"

        storyString+= 
        "Your mission is to hunt down and destroy the " + Klingon.Instances + " Klingon warships in the region.\n" + 
        "You must complete your mission before stardate " + this.endStarDate + ", giving you " + (this.endStarDate - this.starDate) + 
        " stardates to succeed.";

        storyString += 
        "\n\nThere are " + StarBase.Instances + " Federation Starbases in the region for refueling, restocking torpedoes, and repairs.";

        storyString += "\n\nGood luck, galactic peace is in your hands!";

        gameOutputAppend(storyString);
    }

    changeToQuadrant(qX, qY)
    {
        this.currentQuadrant.removeEntity(this.enterprise);
        this.currentQuadrant = this.galaxyMap.lookup(qX, qY);
        this.currentQuadrant.addEntityInFreeSector(this.enterprise);

        gameOutputAppend("Entering galactic sector " + this.enterprise.quadrantString());
    }

    statusString()
    {
        return "<pre>" +
        "\n\n\n" + 
        "STARDATES REMAINING   " + (this.endStarDate - this.starDate) +"\n" +
        "SECTOR                " + (this.enterprise.quadrantX+1) +  ',' + (this.enterprise.quadrantY+1) + '\n' + 
        "SUBSECTOR             " + (this.enterprise.sectorX+1) +  ',' + (this.enterprise.sectorY+1) + "\n" + 
        "PHOTON TORPEDOES      " + this.enterprise.torpedoes + '\n' + 
        "SHIELD ENERGY         " + this.enterprise.shields + '\n' + 
        "FREE ENERGY           " + this.enterprise.freeEnergy + '\n' + 
        "KLINGONS REMAINING    " + Klingon.Instances + '\n' + 
        "STARBASES REMAINING   " + StarBase.Instances + '\n' +
        "</pre>";
    }

    setInputPrompt(newprompt)
    {
        document.getElementById("inputPrompt").innerHTML = newprompt;

    }

    shieldHandler(inputline)
    {
        let parsedVal = parseInt(inputline);

        if (isNaN(parsedVal) || parsedVal < 0)
        {
            gameOutputAppend("Invalid value!");
            return false;
        }
        if (parsedVal > (this.enterprise.shields + this.enterprise.freeEnergy))
        {
            gameOutputAppend("We don't have enough energy for that, captain!");
            return false;
        }
        
        //gameOutputAppend(""+parsedVal);

        this.enterprise.setShieldLevel(parsedVal);

        this.currentQuadrant.klingonsFire(this.enterprise, this);

        return true;
    }

    navigationHandlerLongRangeX(inputline)
    {
        console.log("nav");
        let quadrantX = parseInt(inputline) - 1;

        if ((quadrantX == null) || isNaN(quadrantX) || quadrantX < 0 || quadrantX >= mapWidthQuadrants)
        {
            gameOutputAppend("Invalid value!");
            return false;
        }

        this.awaitInput(
            "Enter destination sector Y coordinate.  Enter a value between 1 and " + mapHeightQuadrants,
            2, 
            
            function(inputline)
            {
                return this.navigationHandlerLongRangeY(inputline, quadrantX);
            }
        );
        
        return false;
    }

    navigationHandlerLongRangeY(inputline, quadrantX)
    {
        let quadrantY = parseInt(inputline) - 1;

        if ((quadrantY == null) || isNaN(quadrantY) || quadrantY < 0 || quadrantY >= mapHeightQuadrants)
        {
            gameOutputAppend("Invalid value!");
            return false;
        }

        let xd = this.enterprise.quadrantX - quadrantX;
        let yd = this.enterprise.quadrantY - quadrantY;
        let travelDistance = Math.sqrt(xd*xd + yd*yd);

        let jumpEnergyRequired = Math.floor(Enterprise.EnergyCostPerQuadrant * travelDistance);

        if (this.enterprise.freeEnergy < jumpEnergyRequired)
        {
            gameOutputAppend("Insufficient energy for long range jump, captain.  Jump requires " + jumpEnergyRequired + " free energy.");
            return true;
        }

        let trekgame = this;
        let confirmMenu = new Menu();
        confirmMenu.options.push
        (
            new MenuOption
            (
                "1", 
                ") ", 
                "CONFIRM JUMP TO QUADRANT " + (quadrantX+1) + ", " + (quadrantY+1) + ".\nTRIP TAKES 1 STARDATE, " + jumpEnergyRequired + " ENERGY\n",
                function()
                {
                    trekgame.enterprise.freeEnergy -= jumpEnergyRequired;
                    trekgame.changeToQuadrant(quadrantX, quadrantY);
                    trekgame.advanceStardate(1.0);
                    return true;
                }
            ),

            new MenuOption
            (
                "2",
                ") ",
                "CANCEL",
                function()
                {
                    return true;
                }
            )
        );

        this.awaitInput(confirmMenu.toString(), 1, function(inputline){return confirmMenu.chooseOption(inputline);});
    }

    navigationHandlerShortRangeX(inputline)
    {
        console.log("nav");
        let subsectorX = parseInt(inputline) - 1;

        if ((subsectorX == null) || isNaN(subsectorX) || subsectorX < 0 || subsectorX >= quadrantWidthSectors)
        {
            gameOutputAppend("Invalid value!");
            return false;
        }

        this.awaitInput(
            "Enter destination subsector (Y coordinate)",
            2, 
            
            function(inputline)
            {
                return this.navigationHandlerShortRangeY(inputline, subsectorX);
            }
        );
        
        return false;
    }

    navigationHandlerShortRangeY(inputline, subsectorX)
    {
        let subsectorY = parseInt(inputline) - 1;

        if ((subsectorY == null) || isNaN(subsectorY) || subsectorY < 0 || subsectorY >= quadrantHeightSectors)
        {
            gameOutputAppend("Invalid value!");
            return false;
        }

        let sectorsToTravel = this.enterprise.distanceToSectorLoc(subsectorX, subsectorY);

        this.enterprise.warp(subsectorX, subsectorY, sectorsToTravel, this);

        this.currentQuadrant.klingonsFire(this.enterprise, this);

        this.advanceStardate(1.0);

        return true;
    }

    torpedoHandler(inputline)
    {
        let angle = parseInt(inputline);

        //console.log(""+angle);
        gameOutputAppend(""+angle);

        if ((angle == null) || isNaN(angle) || angle < 0 || angle > 360.0)
        {
            gameOutputAppend("Invalid value!");
            return false;
        }

        this.enterprise.fireTorpedo(this, angle);

        this.currentQuadrant.klingonsFire(this.enterprise, this);

        return true;
    }

    phaserHandler(inputline)
    {
        let energy = parseInt(inputline);

        if ((energy == null) || isNaN(energy) || energy < 0)
        {
            gameOutputAppend("Invalid value!");
            return false;
        }

        if (energy > this.enterprise.freeEnergy)
        {
            gameOutputAppend("Not enough energy, captain!");
            return false;
        }

        if (energy == 0)
        {
            return true;
        }

        this.enterprise.firePhasers(energy, this);

        this.currentQuadrant.klingonsFire(this.enterprise, this);
        
        return true;
    }

    endGameHandler(inputline)
    {
        if (inputline == 'Y' || inputline == 'y')
        {
            this.endGame();
            return false;
        }
        else if (inputline == 'n' || inputline == 'N')
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    updateStatus()
    {
        document.getElementById("status").innerHTML = this.statusString();
    }

    awaitInput(inputPrompt, charactersToRead=3, inputHandler=null)
    {
        document.getElementById("inputPrompt").style.display="Block";
        document.getElementById("gameInput").style.display="Block";
        document.getElementById("inputButton").style.display ="Block";

        this.inputHandler = inputHandler;
        document.getElementById("gameInput").maxLength = charactersToRead;
        this.setInputPrompt(inputPrompt);
    }

    disableInput()
    {
        document.getElementById("inputPrompt").style.display="None";
        document.getElementById("gameInput").style.display="None";
        document.getElementById("inputButton").style.display ="None";
    }

    handleInput(inputStr)
    {
        gameOutputAppend("\n> "+inputStr+"\n");
        if (this.inputHandler)
        {
            if (this.inputHandler(inputStr))
            {
                this.awaitInput(this.mainMenu.toString(), 3, null);
            }
        }
        else
        {
            this.mainMenu.chooseOption(inputStr);
        }
    }

    gameInput(inputStr)
    {
        //console.log(">"+inputStr+"\n");
        //gameOutputAppend(inputStr);

        this.handleInput(inputStr);

        this.updateGame();
        autosave(this);
    }

    updateDisplay()
    {
        this.updateStatus();
        updateMap(this.updateMapScreen());
        updateMapHeader("SECTOR : " + this.enterprise.quadrantString());
        updateMapFooter(this.updateStatusFlags());
    }

    checkStarbaseDock()
    {
        if (this.enterprise.docked)
        {
            console.log("already docked.");
            return;
        }

        this.mainMenu.dockOption.enabled = false;

        let starbases = this.currentQuadrant.getEntitiesOfType(StarBase);

        for (var x in starbases)
        {
            var sb = starbases[x];

            if (this.enterprise.isAdjacentTo(sb))
            {
                console.log("adjacent");
                this.mainMenu.dockOption.enabled = true;
            }
            else
            {
                console.log("not adjacent");
            }
        }

        if (!this.inputHandler)
        {
            this.awaitInput(this.mainMenu.toString(), 3, null);
        }
    }

    updateGame()
    {
        this.updateDisplay();
        this.starbasesScan();
        this.enterpriseShortRangeScan();
        this.checkStarbaseDock();

        this.checkEndConditions();
    }

    enterpriseShortRangeScan()
    {
        this.enterprise.sensorHistory.updateSensorHistoryForEntityTypes
            (
                [Star, Klingon], 
                this.galaxyMap, 
                this.enterprise.quadrantX, 
                this.enterprise.quadrantY, 
                this.enterprise.quadrantX, 
                this.enterprise.quadrantY
            );
    }

    endGame()
    {
        this.gameOver = true;
        autosave(null);
        gameOutputAppend("\nThanks for playing!  Refresh the page to play again.");
        this.disableInput();
    }

    advanceStardate(adv)
    {
        this.starDate += adv;
        this.enterprise.autoRepairComponents();
    }

    checkEndConditions()
    {
        if (this.gameOver) return;

        if (this.starDate >= this.endStarDate)
        {
            gameOutputAppend("You were unable to complete your mission in time.");
            gameOutputAppend("The Klingons were able to execute their plan to destroy the Federation starbases!");
            gameOutputAppend("You'll be demoted for sure!");

            gameOutputAppend("\nFinal Score : " + this.generateScore(false));

            this.endGame();
        }
        else if (this.enterprise.isStranded())
        {
            gameOutputAppend("You have insufficient energy to power the warp engines!");
            gameOutputAppend("You are stranded, causing you to ultimately fail your mission.");

            gameOutputAppend("\nFinal Score : " + this.generateScore(false));
            
            this.endGame();
        }
        else if (this.enterprise.isDestroyed())
        {
            gameOutputAppend("Your vessel has taken too much damage and has been destroyed.");
            gameOutputAppend("Your mission is failed.");

            gameOutputAppend("\nFinal Score : " + this.generateScore(false));

            this.endGame();
        }
        else if (!StarBase.Instances)
        {
            gameOutputAppend("All the Federation starbases have been destroyed!");
            gameOutputAppend("You've failed in your mission.  The Federation is doomed.");

            gameOutputAppend("\nFinal Score : " + this.generateScore(false));

            this.endGame();
        }
        else if (!Klingon.Instances)
        {
            gameOutputAppend("You've managed to destroy all the enemy vessels, preventing the enemy from executing their plan!");
            gameOutputAppend("You're sure to get a promotion!");
            gameOutputAppend("Congratulations on your victory!");

            gameOutputAppend("\nFinal Score : " + this.generateScore(true));
            
            this.endGame();
        }
    }
    
    createMenus()
    {
        this.mainMenu = new MainMenu(this);
        this.computerMenu = new ShipComputerMenu(this);
    }


    updateStatusFlags()
    {
        let flags = [];
        
        if (this.enterprise.docked)
        {
            flags.push("DOCKED");
        }

        if (this.currentQuadrant.countEntitiesOfType(Klingon))
        {
            flags.push("RED ALERT");

            if (this.enterprise.isShieldLevelCritical(this.currentQuadrant.getEntitiesOfType(Klingon)))
            {
                flags.push("SHIELDS CRITICAL");
            }
        }
        else
        {
            flags.push("SECTOR CLEAR");
        }

        return flags.join(" | ");
    }

    updateMapScreen()
    {
        let quad = this.currentQuadrant;

        let borderStringPost = "   " + mapFooter(quadrantWidthSectors);
        let borderStringPre = "   " + mapHeader(quadrantWidthSectors) + '\n';

        let quadrantStringGrid = new Grid(quad.width, quad.height, function(){return " ".padStart(sectorDisplayWidthChars, ' ')})

        var gameObjectIndex;
        for (gameObjectIndex in quad.quadrantEntities)
        {
            let gameObject = quad.quadrantEntities[gameObjectIndex];
            var objStr;
        
            objStr = gameObject.toString().padStart(sectorDisplayWidthChars, ' ');

            quadrantStringGrid.setValue(gameObject.sectorX, gameObject.sectorY, objStr);
        }

        let healthOK = this.enterprise.components.ShortRangeSensors.componentHealth > Enterprise.SRSFullyFunctionalHealth;

        if (!healthOK)
        {
            // goes from 0 when the component is at the maximum health in range, to 1 when the component is at 0%
            let hnorm = (Enterprise.SRSFullyFunctionalHealth - this.enterprise.components.ShortRangeSensors.componentHealth) / Enterprise.SRSFullyFunctionalHealth;

            // lerp
            let chanceCorrupt = (1.0 - hnorm) * Enterprise.SRSMinChanceCorrupt + hnorm * Enterprise.SRSMaxChanceCorrupt;

            // randomly go through and corrupt the short range scan based on the health of the ship components
            for (var x in quadrantStringGrid.contents)
            {
                let corrupt = Math.random() < chanceCorrupt;
                
                if (corrupt)
                {
                    quadrantStringGrid.setValue1D(x, '?'.padStart(sectorDisplayWidthChars, ' '));
                }
            }
        }

        let mapString = quadrantStringGrid.toString();

        return "<pre>" + borderStringPre + mapString + borderStringPost + "</pre>";

    }
}

TrekGame.EntityTypes = [Star, StarBase, Klingon];
TrekGame.BaseMissionTime = 25;
TrekGame.MissionTimeSpread = 10;

function createEntityMap(entityList)
{
    var map = new Map();
    var x;
    for (x in entityList)
    {
        let etype = entityList[x];
        map.set(etype.name, etype);
    }
    return map;
}

const EntityMap = createEntityMap(TrekGame.EntityTypes);

console.log("Hope you enjoy the game!");